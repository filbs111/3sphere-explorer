<!DOCTYPE html>
<html>

<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<title>3-sphere explorer</title>

<style>
	body {
		margin: 0px;
		overflow: hidden;
	}

	#info {
		position: absolute;
		top: 0px; width: 100%;
		padding: 20px;
		color: white;
		text-align: center;
	}
	
	#info a:link {
				color: white;
	}
		
	#info a:visited {
		color: white;
	}
</style>

<script type="text/javascript" src="lib/dat.gui.min.js"></script>
<script type="text/javascript" src="lib/stats.min.js"></script>
<script type="text/javascript" src="lib/gl-matrix-min.js"></script>
<script type="text/javascript" src="utils/fullscreen.js"></script>
<script type="text/javascript" src="utils/webgl_utils.js"></script>
<script type="text/javascript" src="utils/keys.js"></script>
<script type="text/javascript" src="data/sphere.js"></script>
<script type="text/javascript" src="data/levelCubeData.js"></script>
<script type="text/javascript" src="data/tennisBall.js"></script>
<script type="text/javascript" src="data/grid1.obj.json.min"></script>
<script type="text/javascript" src="data/terrain/untitled64tri-deduped-wrap.obj.json.min"></script>
<script type="text/javascript" src="data/tennisBallLoader.js"></script>
<script type="text/javascript" src="data/cube-frame-a1-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/cube-frame-a2-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/octohedron-nosubdiv-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/octohedron-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/tetra-frame.obj.json"></script>
<script type="text/javascript" src="data/tetra-frame1-subdiv.obj.json"></script>
<script type="text/javascript" src="data/dodecahedron-frame-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/wt_teapot-trimmed.obj.json"></script>
<script type="text/javascript" src="data/sship-pointyc-tidy1-triang.obj.json"></script>
<script type="text/javascript" src="data/guncyl.obj.json"></script>
<script type="text/javascript" src="data/icoball.obj.json"></script>
<script type="text/javascript" src="utils/matfuncs.js"></script>
<script type="text/javascript" src="data/cells.js"></script>

<!-- simple pix shader -->
<script id="shader-simple-fs" type="x-shader/x-fragment">
	//#extension GL_EXT_frag_depth : enable

	precision mediump float;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying float light;
	
	void main(void) {
		gl_FragColor = vec4( fog*( vec3(light) + uFogColor.xyz )*uColor.xyz, 1.0) + (1.0-fog)*uFogColor;
	}
</script>
<!-- vertex shader -->
<!-- note that taking in 3vector for vertex positions since generally objects are significantly smaller than the 3-sphere radius, so can project them onto unit 3sphere
(set w=1 and normalise to r=1) or j ust set w=1. --> 
<!-- if normalisation is used, i expect will be more efficient to generate 4-vector vertiex buffers and pass those in -->
<!-- mvmatrix will be an SO4 matrix. pmatrix will try a standard projection matrix -->
<!-- possibly want to output additional varying to pass some depth variable -->
<!-- TODO use textured shader to check that that interpolates in sensible way (ie perspective projection observed for rectangles). -->
<script id="shader-simple-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying float fog;
	uniform vec3 uModelScale;
	varying float light;
			
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		gl_Position = uPMatrix * transformedCoord;

		vec4 transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.7 + 3.0*dot(adjustedPos,adjustedPos);	//1st num some const to ensure light doesn't go inf at short dist
													//guess maybe similar to some gaussian light source
		fog = 0.5*(1.0 + transformedCoord.w);
	}
</script>


<!-- tex mapped pix shader -->
<script id="shader-texmap-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying vec3 veclight;
	
	void main(void) {
		//gl_FragColor = uColor*texture2D(uSampler, vTextureCoord);
		
		gl_FragColor = vec4( fog*( veclight + uFogColor.xyz ), 1.0)*uColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
	}
</script>

<!-- per pixel lighting -->
<!-- expect can make this more efficient -->
<script id="shader-perpixel-fs" type="x-shader/x-fragment">
	//#extension GL_EXT_frag_depth : enable

	precision mediump float;
	uniform vec4 uColor;
	uniform vec4 uFogColor;
	varying float fog;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	
	void main(void) {
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.7 + 3.0*dot(adjustedPos,adjustedPos);	//1st num some const to ensure light doesn't go inf at short dist
													//guess maybe similar to some gaussian light source
		gl_FragColor = vec4( fog*( vec3(light) + uFogColor.xyz )*uColor.xyz, 1.0) + (1.0-fog)*uFogColor;
	}
</script>
<script id="shader-perpixel-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uModelScale;
	varying float fog;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		
		fog = 0.5*(1.0 + transformedCoord.w);
	}
</script>

<!-- discard fragments inside reflector (when rendering cubemap view from inside reflector -->
<script id="shader-perpixel-discard-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform vec4 uColor;
	uniform vec3 uPlayerLightColor;
	uniform vec4 uFogColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec4 adjustedPos;
	varying vec4 adjustedPos2;
	varying vec4 transformedNormal;
	varying vec4 transformedCoord;
	
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		if (posCosDiff>0.0){
			discard;
		}
	
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.7 + 3.0*dot(adjustedPos,adjustedPos);	//1st num some const to ensure light doesn't go inf at short dist
		
		float light2 = -dot( normalize(adjustedPos2), transformedNormal);
		light2 = max(light2,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light2/=0.7 + 3.0*dot(adjustedPos2,adjustedPos2);	
		
		light+=light2;
		
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		float portalLight = dot( uReflectorPos, transformedNormal);
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
		
		
		//ensure isn't something wierd! should be between -1, 1
		//if (portalLight>0.95){portalLight=-0.9;}
		//if (portalLight<-0.95){portalLight=0.9;}
		//portalLight=0.0;
				
		//guess maybe similar to some gaussian light source
		gl_FragColor = vec4( fog*( uPlayerLightColor*light+ uReflectorDiffColor*portalLight + uFogColor.xyz )*uColor.xyz, 1.0) + (1.0-fog)*uFogColor;
		
		//gl_FragColor.a =1.0;
	}
</script>
<script id="shader-perpixel-discard-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec4 uDropLightPos2;
	uniform vec3 uModelScale;
	varying float fog;
	varying vec4 adjustedPos;
	varying vec4 adjustedPos2;
	varying vec4 transformedNormal;
	varying vec4 transformedCoord;
	
	void main(void) {	
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		adjustedPos2 = transformedCoord - uDropLightPos2;
		
		fog = 0.5*(1.0 + transformedCoord.w);
	}
</script>




<script id="shader-texmap-perpixel-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	
	void main(void) {
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.7 + 3.0*dot(adjustedPos,adjustedPos);
		
		gl_FragColor = vec4( fog*( vec3(light) + uFogColor.xyz ), 1.0)*uColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
	}
</script>

<script id="shader-texmap-perpixel-discard-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	uniform vec3 uPlayerLightColor;
	varying float fog;
	uniform vec4 uFogColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying vec4 adjustedPos;
	varying vec4 adjustedPos2;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;	
	
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		if (posCosDiff>0.0){
			discard;
		}
	
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.7 + 3.0*dot(adjustedPos,adjustedPos);
		
		float light2 = -dot( normalize(adjustedPos2), transformedNormal);
		light2 = max(light2,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light2/=0.7 + 3.0*dot(adjustedPos2,adjustedPos2);
		
		light+=light2;
		
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		//guess maybe similar to some gaussian light source
		gl_FragColor = vec4( fog*( uPlayerLightColor*light + uReflectorDiffColor*portalLight + uFogColor.xyz ), 1.0)*uColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;

		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
	}
</script>

<!-- vertex shader with tex coords -->
<script id="shader-texmap-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying float fog;
	uniform vec3 uModelScale;
	varying vec3 veclight;
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		
		gl_Position = uPMatrix * transformedCoord;

		vec4 transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.7 + 3.0*dot(adjustedPos,adjustedPos);	//1st num some const to ensure light doesn't go inf at short dist
													//guess maybe similar to some gaussian light source
		
		veclight=vec3(light);
		
		fog = 0.5*(1.0 + transformedCoord.w);
		
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>


<!-- vertex shader with tex coords, per pixel -->
<script id="shader-texmap-perpixel-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying float fog;
	uniform vec3 uModelScale;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		
		fog = 0.5*(1.0 + transformedCoord.w);

		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>

<!-- vertex shader with tex coords, per pixel -->
<script id="shader-texmap-perpixel-discard-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec4 uDropLightPos2;
	varying float fog;
	uniform vec3 uModelScale;
	varying vec4 adjustedPos;
	varying vec4 adjustedPos2;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		adjustedPos2 = transformedCoord - uDropLightPos2;
		
		fog = 0.5*(1.0 + transformedCoord.w);

		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>


<!-- vertex shader with tex coords and 4vector input positions (instead of projected 3vectors.)-->
<script id="shader-texmap-vs-4vec" type="x-shader/x-vertex">
	attribute vec4 aVertexPosition;
	attribute vec4 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec4 uDropLightPos2;
	uniform vec3 uPlayerLightColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec3 veclight;
	
	void main(void) {
		vec4 transformedCoord = uMVMatrix * aVertexPosition;
		
		gl_Position = uPMatrix * transformedCoord;
		
		fog = 0.5*(1.0 + transformedCoord.w);
		
		vec4 transformedNormal = uMVMatrix * aVertexNormal;
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		light/=1.0 + 4.2*dot(adjustedPos,adjustedPos);		//terms higher than other shaders by sqrt(2) because length
															//of 1,0,0,0 -> 0,1,0,0 (90 deg around world)
		
		//TODO can process multiple lights using matrix?
		vec4 adjustedPos2 = transformedCoord - uDropLightPos2;
		float light2 = -dot( normalize(adjustedPos2), transformedNormal);
		light2 = max(light2,0.0);
		light2/=1.0 + 4.2*dot(adjustedPos2,adjustedPos2);
		
		light+=light2;
		
		veclight=uPlayerLightColor*light;
		
		
		
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		veclight+=uReflectorDiffColor*portalLight;
				
		vTextureCoord = vec3( aTextureCoord.st, 1.0 );
	}
</script>


<!-- simple cubemap pix shader -->
<script id="shader-cubemap-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform samplerCube uSampler;
	varying vec3 vPos;
	varying float fog;
	uniform vec4 uColor;	//TODO remove? (should be white, but useful to tint for debug/ coloured reflector)
	uniform vec4 uFogColor;
	
	void main(void) {
		//gl_FragColor = uColor*textureCube(uSampler, vPos);	//TODO use this (get rid of fog)
		gl_FragColor = vec4( vec3(fog), 1.0)*uColor*textureCube(uSampler, vPos) + (1.0-fog)*uFogColor;
	}
</script>
<!-- vertex shader -->
<script id="shader-cubemap-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	varying vec3 vPos;
	varying float fog;	//TODO remove (fog should be applied at cubemap generation (unless fog is exponential decay)
	uniform vec3 uModelScale;
	uniform mat4 uPosShiftMat;
	uniform float uPolarity;

	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));	//project 3d object onto 3sphere
																//can avoid this by inputting 4vector positions *...
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		fog = 0.5*(1.0 + transformedCoord.w);
	
		//gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); // *... or can just use 1.0 without normalising? TODO try.
		gl_Position = uPMatrix * transformedCoord;
		
		vPos = uPolarity * (uPosShiftMat*aVertexPositionNormalized).xyz;
	}
</script>


<script id="shader-cubemap-vertproj-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	varying vec3 vPos;
	varying float fog;	//TODO remove (fog should be applied at cubemap generation (unless fog is exponential decay)
	uniform vec3 uModelScale;
	uniform mat4 uPosShiftMat;
	uniform vec3 uCentrePosScaled;	//this is position of cubemap centre point in unprojected model space
	uniform float uPolarity;
	
	void main(void) {
		float csq = dot(uCentrePosScaled,uCentrePosScaled);
		float cdotp = dot(uCentrePosScaled, -aVertexPosition);
		float a = pow((1.0-csq)+cdotp*cdotp, 0.5) - cdotp;
		vec3 scaledVertexPosition = aVertexPosition*a;
	
		vec4 aVertexPositionNormalized = normalize(vec4( uModelScale*(scaledVertexPosition-uCentrePosScaled), 1.0));	
		
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		fog = 0.5*(1.0 + transformedCoord.w);
	
		gl_Position = uPMatrix * transformedCoord;
		
		vPos = uPolarity * (uPosShiftMat*aVertexPositionNormalized).xyz;
	}
</script>




<script type="text/javascript" src="js/main.js"></script>




</head>



<body onload="init()">
<div id="info">3-sphere visualised in WebGL demo. Arrow keys, QE, click+drag mouse to rotate. WASD, space/ctrl to translate.<a href="https://github.com/filbs111/3sphere-explorer" target="_blank">https://github.com/filbs111/3sphere-explorer</a></div>
		

<canvas id="mycanvas" width="0" height="0">CANVAS TO GO HERE</canvas>


</body>


</html>