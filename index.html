<!DOCTYPE html>
<html>

<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<title>3-sphere explorer</title>

<style>
	body {
		margin: 0px;
		overflow: hidden;
	}

	#info {
		position: absolute;
		top: 0px; width: 100%;
		padding: 20px;
		color: white;
		text-align: center;
	}
	
	#info2 {
		position: absolute;
		top: 10%; width: 100%;
		padding: 20px;
		color: white;
		text-align: left;
	}
	
	#info a:link {
				color: white;
	}
		
	#info a:visited {
		color: white;
	}
</style>

<script type="text/javascript" src="lib/dat.gui.min.js"></script>
<script type="text/javascript" src="lib/stats.min.js"></script>
<script type="text/javascript" src="lib/gl-matrix-min.js"></script>
<script type="text/javascript" src="utils/matfuncs.js"></script>
<script type="text/javascript" src="utils/fullscreen.js"></script>
<script type="text/javascript" src="utils/webgl_utils.js"></script>
<script type="text/javascript" src="utils/keys.js"></script>
<script type="text/javascript" src="utils/gamepad_settings.js"></script>
<script type="text/javascript" src="utils/multisound.js"></script>
<script type="text/javascript" src="data/sphere.js"></script>
<script type="text/javascript" src="data/quad.js"></script>
<script type="text/javascript" src="data/levelCubeData.js"></script>
<script type="text/javascript" src="data/explodingCubeData.js"></script>
<script type="text/javascript" src="data/tennisBall.js"></script>
<script type="text/javascript" src="data/grid1.obj.json.min"></script>
<script type="text/javascript" src="data/terrain/untitled64tri-deduped-wrap.obj.json.min"></script>
<script type="text/javascript" src="data/gridData.js"></script>
<script type="text/javascript" src="data/proceduralTerrain.js"></script>
<script type="text/javascript" src="data/duocylinderBoxInfo.js"></script>
<script type="text/javascript" src="data/tennisBallLoader.js"></script>
<script type="text/javascript" src="data/cube-frame-a1-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/cube-frame-a2-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/octohedron-nosubdiv-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/octohedron-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/tetra-frame.obj.json"></script>
<script type="text/javascript" src="data/tetra-frame1-subdiv.obj.json"></script>
<script type="text/javascript" src="data/dodecahedron-frame-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/wt_teapot-trimmed.obj.json"></script>
<!--<script type="text/javascript" src="data/sship-pointyc-tidy1-triang.obj.json"></script>-->
<script type="text/javascript" src="data/dirLight/sship-pointyc-tidy1-uv5-YZ-p04scale.obj.json""></script>
<script type="text/javascript" src="data/guncyl.obj.json"></script>
<script type="text/javascript" src="data/icoball.obj.json"></script>
<script type="text/javascript" src="data/hyperboloidData.js"></script>
<script type="text/javascript" src="data/cells.js"></script>
<script type="text/javascript" src="data/ringCells.js"></script>


<!-- tex mapped decal pix shader -->
<script id="shader-decal-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	
	void main(void) {
		gl_FragColor = uColor*texture2DProj(uSampler, vTextureCoord);	//TODO don't use projective texture if not necessary! (eg for quads)
		//gl_FragColor = uColor;
	}
</script>

<!-- vertex shader with tex coords -->
<script id="shader-decal-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec3 uModelScale;
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		gl_Position = uPMatrix * transformedCoord;
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>

<!-- simple pix shader -->
<script id="shader-simple-fs" type="x-shader/x-fragment">
	//#extension GL_EXT_frag_depth : enable

	precision mediump float;
	uniform vec4 uColor;
	uniform vec3 uEmitColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying float light;
	
	void main(void) {
		gl_FragColor = vec4( fog*(( vec3(light) + uFogColor.xyz )*uColor.xyz + uEmitColor), 1.0) + (1.0-fog)*uFogColor;
	}
</script>
<!-- vertex shader -->
<!-- note that taking in 3vector for vertex positions since generally objects are significantly smaller than the 3-sphere radius, so can project them onto unit 3sphere
(set w=1 and normalise to r=1) or j ust set w=1. --> 
<!-- if normalisation is used, i expect will be more efficient to generate 4-vector vertiex buffers and pass those in -->
<!-- mvmatrix will be an SO4 matrix. pmatrix will try a standard projection matrix -->
<!-- possibly want to output additional varying to pass some depth variable -->
<!-- TODO use textured shader to check that that interpolates in sensible way (ie perspective projection observed for rectangles). -->
<script id="shader-simple-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying float fog;
	uniform vec3 uModelScale;
	varying float light;
			
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		gl_Position = uPMatrix * transformedCoord;

		vec4 transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.7 + 3.0*dot(adjustedPos,adjustedPos);	//1st num some const to ensure light doesn't go inf at short dist
													//guess maybe similar to some gaussian light source
		fog = 0.5*(1.0 + transformedCoord.w);
	}
</script>


<!-- tex mapped pix shader -->
<script id="shader-texmap-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying vec3 veclight;
	
	void main(void) {
		//gl_FragColor = uColor*texture2D(uSampler, vTextureCoord);
		
		vec4 preGammaFragColor = vec4( fog*( veclight + uFogColor.xyz ), 1.0)*uColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		//gl_FragColor = vec4( pow(preGammaFragColor.r,0.455), pow(preGammaFragColor.g,0.455), pow(preGammaFragColor.b,0.455), pow(preGammaFragColor.a,0.455));
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
	}
</script>


<!-- tex mapped pix shader -->
<script id="shader-texmap-fs-mapproject" type="x-shader/x-fragment">
	#define CONST_TAU 6.2831853
	#define CONST_REPS 16.0
	
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying vec3 veclight;
	varying vec4 vVertexPos;
	
	void main(void) {
		//gl_FragColor = uColor*texture2D(uSampler, vTextureCoord);
	
		vec2 newTexCoord = vec2( atan(vVertexPos.x,vVertexPos.y)*CONST_REPS/CONST_TAU, atan(vVertexPos.z,vVertexPos.w)*CONST_REPS/CONST_TAU);
		
		//gl_FragColor = vec4( fog*( veclight + uFogColor.xyz ), 1.0)*uColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		vec4 preGammaFragColor = vec4( fog*( veclight + uFogColor.xyz ), 1.0)*uColor*texture2D(uSampler, newTexCoord) + (1.0-fog)*uFogColor;
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		//gl_FragColor = vec4( pow(preGammaFragColor.r,0.455), pow(preGammaFragColor.g,0.455), pow(preGammaFragColor.b,0.455), pow(preGammaFragColor.a,0.455));
		
		
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
	}
</script>



<!-- no tex pix shader -->
<script id="shader-flat-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying vec3 veclight;
	
	void main(void) {
		gl_FragColor = vec4( fog*( veclight + uFogColor.xyz ), 1.0)*uColor + (1.0-fog)*uFogColor;
		//gl_FragColor = vec4(1.,0.,0.,1.);
		//gl_FragColor = uColor;
		gl_FragColor.a =1.0;
	}
</script>

<!-- per pixel lighting -->
<!-- expect can make this more efficient -->
<script id="shader-perpixel-fs" type="x-shader/x-fragment">
	//#extension GL_EXT_frag_depth : enable

	precision mediump float;
	uniform vec4 uColor;
	uniform vec3 uEmitColor;
	uniform vec4 uFogColor;
	varying float fog;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	
	void main(void) {
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.7 + 3.0*dot(adjustedPos,adjustedPos);	//1st num some const to ensure light doesn't go inf at short dist
													//guess maybe similar to some gaussian light source
		gl_FragColor = vec4( fog*(( vec3(light) + uFogColor.xyz )*uColor.xyz + uEmitColor), 1.0) + (1.0-fog)*uFogColor;
	}
</script>
<script id="shader-perpixel-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uModelScale;
	varying float fog;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		
		fog = 0.5*(1.0 + transformedCoord.w);
	}
</script>

<!-- discard fragments inside reflector (when rendering cubemap view from inside reflector -->
<script id="shader-perpixel-discard-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform vec4 uColor;
	uniform vec3 uEmitColor;
	uniform vec3 uPlayerLightColor;
	uniform vec4 uFogColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	varying vec4 transformedCoord;
	
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		if (posCosDiff>0.0){
			discard;
		}
	
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.7 + 3.0*dot(adjustedPos,adjustedPos);	//1st num some const to ensure light doesn't go inf at short dist
		
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		float portalLight = dot( uReflectorPos, transformedNormal);
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
		
		
		//ensure isn't something wierd! should be between -1, 1
		//if (portalLight>0.95){portalLight=-0.9;}
		//if (portalLight<-0.95){portalLight=0.9;}
		//portalLight=0.0;
				
		//guess maybe similar to some gaussian light source
		
		vec4 preGammaFragColor = vec4( fog*(( uPlayerLightColor*light+ uReflectorDiffColor*portalLight + uFogColor.xyz )*uColor.xyz + uEmitColor), 1.0) + (1.0-fog)*uFogColor;
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		//gl_FragColor = vec4( pow(preGammaFragColor.r,0.455), pow(preGammaFragColor.g,0.455), pow(preGammaFragColor.b,0.455), pow(preGammaFragColor.a,0.455));
		
		gl_FragColor.a =uColor.a;	//TODO confirm check logic for transparent objects
	}
</script>
<script id="shader-perpixel-discard-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uModelScale;
	varying float fog;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	varying vec4 transformedCoord;
	
	void main(void) {	
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		
		fog = 0.5*(1.0 + transformedCoord.w);
	}
</script>
<script id="shader-perpixel-discard-vs-atmos" type="x-shader/x-vertex">
	#define CONST_ITERS 64.0

	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uModelScale;
	varying float fog;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	varying vec4 transformedCoord;
	
	void main(void) {	
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		
		/*
		fog = 0.5*(1.0 + transformedCoord.w);
		//note 1.0 = no fog, 0 = total fog.
		//more complex fog calculation. show that can have radial dependence. not anything like physically correct!
		float airDensityAtObj = exp(-dot(worldCoord.xy,worldCoord.xy));
		fog*=airDensityAtObj; 
		*/
		
		//although this is used for "per pixel" version, currently calculating fog per vertex.
		
		/*
		float dotProd = dot(uCameraWorldPos,worldCoord);
		float maxAng = acos(dotProd);	//angle from camera to object
		float maxAngOverIters = maxAng/CONST_ITERS;
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		float totalPath=0.0;
		float currentAngle;
		vec4 currentPos;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			currentAngle=maxAngOverIters*aa;
			currentPos = uCameraWorldPos*cos(currentAngle)+normalDirection*sin(currentAngle);
			totalPath+=exp(uAtmosContrast*dot(currentPos.xy,currentPos.xy));	//number here affects how different atmos pressure is between extremes
		}
		fog=exp(-totalPath*uAtmosThickness*maxAngOverIters);
		*/
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd);
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float total=0.0;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
	}
</script>

<script id="shader-perpixel-discard-vs-atmos-v2" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uModelScale;
	varying float fog;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	varying vec4 transformedCoord;
	
	void main(void) {	
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd);
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
	}
</script>

<!-- move along normals by uNormalMove. with view to per vertex velocity data -->
<script id="shader-perpixel-discard-vs-atmos-v2-explode" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uModelScale;
	uniform float uVertexMove;
	varying float fog;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	varying vec4 transformedCoord;
	
	void main(void) {
		vec3 shiftedPosition = uModelScale*aVertexPosition + uVertexMove*aVertexNormal;
		vec4 aVertexPositionNormalized = normalize(vec4(shiftedPosition, 1.0));
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd);
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
	}
</script>


<script id="shader-perpixel-transparent-discard-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform vec3 uEmitColor;

	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;	//note currently assume fog distance same for all colours
	varying vec4 transformedCoord;
	varying vec4 transformedNormal;
	
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
		if (posCosDiff>0.0){
			discard;
		}
		
		//some hack for falloff by ~normal dot camera direction to make edges of spherical explosions fade out
		//float light = dot( normalize(transformedCoord).xyz, transformedNormal.xyz);
		//float light = transformedNormal.z;	//this very approx.
		//todo actually dot with direction to camera, divide by sqrt(1-wsq) ? (guess currently get excessive depth falloff)
											//probably should just combo with "fog" value calculation in vert shader
		
		//gl_FragColor = vec4(uEmitColor, fog*light);
		gl_FragColor = vec4(uEmitColor, fog);
	}
</script>
<script id="shader-perpixel-transparent-discard-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec3 uModelScale;
	varying float fog;
	varying vec4 transformedCoord;
	varying vec4 transformedNormal;
	
	void main(void) {	
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		gl_Position = uPMatrix * transformedCoord;
		
		fog = 0.5*(1.0 + transformedCoord.w);
	}
</script>



<script id="shader-texmap-perpixel-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	
	void main(void) {
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.7 + 3.0*dot(adjustedPos,adjustedPos);
		
		gl_FragColor = vec4( fog*( vec3(light) + uFogColor.xyz ), 1.0)*uColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
	}
</script>

<script id="shader-texmap-perpixel-discard-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	uniform vec3 uPlayerLightColor;
	varying float fog;
	uniform vec4 uFogColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;	
		
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		if (posCosDiff>0.0){
			discard;
		}
	
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.7 + 3.0*dot(adjustedPos,adjustedPos);
		
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		//guess maybe similar to some gaussian light source
		vec4 preGammaFragColor = vec4( fog*( uPlayerLightColor*light + uReflectorDiffColor*portalLight + uFogColor.xyz ), 1.0)*uColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;

		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		//gl_FragColor = vec4( pow(preGammaFragColor.r,0.455), pow(preGammaFragColor.g,0.455), pow(preGammaFragColor.b,0.455), pow(preGammaFragColor.a,0.455));
	
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
	}
</script>

<script id="shader-texmap-perpixel-gradlight-discard-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	uniform vec3 uPlayerLightColor;
	varying float fog;
	uniform vec4 uFogColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;	
	
	uniform vec3 uLightPosPlayerFrame;	//tmp. TODO do this stuff in v shader
	
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		if (posCosDiff>0.0){
			discard;
		}
	
	/*
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.7 + 3.0*dot(adjustedPos,adjustedPos);
	*/
		//tmp remove player light 
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);										
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
		
		//bodge - treat as if gradient light, where centre colour = uFogColor + 0.5*(uReflectorDiffColor*portalLight), gradient = uReflectorDiffColor*portalLight
		//TODO maybe better to approximate light as some percentage standard directional light, some amount gradient (all gradient at portal surface)
		//maybe quadratic gradient light will be significant improvement (but may require many textures)
		vec3 averageLight = uFogColor.xyz + uReflectorDiffColor * (0.5 / (1.0 + 3.0*dot(posCosDiff,posCosDiff)));
			//calculation contribution of gradient lights and sum. this is portalLight vector basically.
		
		//vec3 modifiedLightDirection = vec3(0.5,-0.5,0.0);	//TODO use correct
		vec3 modifiedLightDirection = normalize(uLightPosPlayerFrame.xyz);	//TODO scale less when far from portal surf (by difference betwee "average" colour and fog) 
		vec3 modifiedLightDirectionR = modifiedLightDirection*uReflectorDiffColor.r;	//todo matrix notation, do in vert shader
		vec3 modifiedLightDirectionG = modifiedLightDirection*uReflectorDiffColor.g;
		vec3 modifiedLightDirectionB = modifiedLightDirection*uReflectorDiffColor.b;
		
		vec4 vChanWeightsR = vec4(modifiedLightDirectionR, averageLight.r-dot(modifiedLightDirectionR,vec3(0.5)));
		vec4 vChanWeightsG = vec4(modifiedLightDirectionG, averageLight.g-dot(modifiedLightDirectionG,vec3(0.5)));
		vec4 vChanWeightsB = vec4(modifiedLightDirectionB, averageLight.b-dot(modifiedLightDirectionB,vec3(0.5)));
		
		float uMaxAlbedo = 0.4;	//todo use uColor? (baked maps assume some albedo though)
		vChanWeightsR*=uMaxAlbedo;
		vChanWeightsG*=uMaxAlbedo;
		vChanWeightsB*=uMaxAlbedo;	//todo just apply after litColor
		
		vec3 litColor = vec3( dot(texture2DProj(uSampler, vTextureCoord), vChanWeightsR), 
								dot(texture2DProj(uSampler, vTextureCoord), vChanWeightsG),
								dot(texture2DProj(uSampler, vTextureCoord), vChanWeightsB));
		
		//guess maybe similar to some gaussian light source
		//vec4 preGammaFragColor = vec4( fog*( uPlayerLightColor*light + uReflectorDiffColor*portalLight + uFogColor.xyz ), 1.0)*uColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		vec4 preGammaFragColor = vec4( fog*litColor, 1.0) + (1.0-fog)*uFogColor;

		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		//gl_FragColor = vec4( pow(preGammaFragColor.r,0.455), pow(preGammaFragColor.g,0.455), pow(preGammaFragColor.b,0.455), pow(preGammaFragColor.a,0.455));
	
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
	}
</script>

<!-- vertex shader with tex coords -->
<script id="shader-texmap-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying float fog;
	uniform vec3 uModelScale;
	varying vec3 veclight;
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		
		gl_Position = uPMatrix * transformedCoord;

		vec4 transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.7 + 3.0*dot(adjustedPos,adjustedPos);	//1st num some const to ensure light doesn't go inf at short dist
													//guess maybe similar to some gaussian light source
		
		veclight=vec3(light);
		
		fog = 0.5*(1.0 + transformedCoord.w);
		
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>


<!-- vertex shader with tex coords, per pixel -->
<script id="shader-texmap-perpixel-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying float fog;
	uniform vec3 uModelScale;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		
		fog = 0.5*(1.0 + transformedCoord.w);

		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>

<!-- vertex shader with tex coords, per pixel -->
<script id="shader-texmap-perpixel-discard-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying float fog;
	uniform vec3 uModelScale;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		
		fog = 0.5*(1.0 + transformedCoord.w);
		
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>


<script id="shader-texmap-perpixel-discard-atmos-vs" type="x-shader/x-vertex">
	#define CONST_ITERS 64.0

	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying float fog;
	uniform vec3 uModelScale;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		/*
		fog = 0.5*(1.0 + transformedCoord.w);
		//note 1.0 = no fog, 0 = total fog.
		//more complex fog calculation. show that can have radial dependence. not anything like physically correct!
		float airDensityAtObj = exp(-dot(worldCoord.xy,worldCoord.xy));
		fog*=airDensityAtObj; 
		*/
		
		/*
		float dotProd = dot(uCameraWorldPos,worldCoord);
		float maxAng = acos(dotProd);	//angle from camera to object
		float maxAngOverIters = maxAng/CONST_ITERS;
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		float totalPath=0.0;
		float currentAngle;
		vec4 currentPos;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			currentAngle=maxAngOverIters*aa;
			currentPos = uCameraWorldPos*cos(currentAngle)+normalDirection*sin(currentAngle);
			totalPath+=exp(uAtmosContrast*dot(currentPos.xy,currentPos.xy));	//number here affects how different atmos pressure is between extremes
		}
		fog=exp(-totalPath*uAtmosThickness*maxAngOverIters);
		*/
		
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd);
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float total=0.0;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
		
		
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>

<script id="shader-texmap-perpixel-discard-atmos-vertvel-vs" type="x-shader/x-vertex">
	#define CONST_ITERS 64.0

	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	attribute vec3 aVertexVelocity;
	varying vec3 vTextureCoord;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform float uVertexMove;
	varying float fog;
	uniform vec3 uModelScale;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;
	
	void main(void) {
		vec3 shiftedPosition = uModelScale*aVertexPosition + aVertexVelocity*uVertexMove;
		vec4 aVertexPositionNormalized = normalize(vec4(shiftedPosition, 1.0));
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		/*
		fog = 0.5*(1.0 + transformedCoord.w);
		//note 1.0 = no fog, 0 = total fog.
		//more complex fog calculation. show that can have radial dependence. not anything like physically correct!
		float airDensityAtObj = exp(-dot(worldCoord.xy,worldCoord.xy));
		fog*=airDensityAtObj; 
		*/
		
		/*
		float dotProd = dot(uCameraWorldPos,worldCoord);
		float maxAng = acos(dotProd);	//angle from camera to object
		float maxAngOverIters = maxAng/CONST_ITERS;
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		float totalPath=0.0;
		float currentAngle;
		vec4 currentPos;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			currentAngle=maxAngOverIters*aa;
			currentPos = uCameraWorldPos*cos(currentAngle)+normalDirection*sin(currentAngle);
			totalPath+=exp(uAtmosContrast*dot(currentPos.xy,currentPos.xy));	//number here affects how different atmos pressure is between extremes
		}
		fog=exp(-totalPath*uAtmosThickness*maxAngOverIters);
		*/
		
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd);
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float total=0.0;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
		
		
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>



<script id="shader-texmap-perpixel-discard-atmos-v2-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying float fog;
	uniform vec3 uModelScale;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		/*
		fog = 0.5*(1.0 + transformedCoord.w);
		//note 1.0 = no fog, 0 = total fog.
		//more complex fog calculation. show that can have radial dependence. not anything like physically correct!
		float airDensityAtObj = exp(-dot(worldCoord.xy,worldCoord.xy));
		fog*=airDensityAtObj; 
		*/
		
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd);
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);	
		
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>



<script id="shader-texmap-perpixel-discard-atmos-v2-vertvel-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	attribute vec3 aVertexVelocity;
	varying vec3 vTextureCoord;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform float uVertexMove;
	varying float fog;
	uniform vec3 uModelScale;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;
	
	void main(void) {
		vec3 shiftedPosition = uModelScale*aVertexPosition + aVertexVelocity*uVertexMove;
		//vec3 shiftedPosition = uModelScale*aVertexPosition + vec3(10.0)*uVertexMove;
		vec4 aVertexPositionNormalized = normalize(vec4(shiftedPosition, 1.0));
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		/*
		fog = 0.5*(1.0 + transformedCoord.w);
		//note 1.0 = no fog, 0 = total fog.
		//more complex fog calculation. show that can have radial dependence. not anything like physically correct!
		float airDensityAtObj = exp(-dot(worldCoord.xy,worldCoord.xy));
		fog*=airDensityAtObj; 
		*/
		
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd);
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);	
		
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>



<!-- vertex shader with tex coords and 4vector input positions (instead of projected 3vectors.)-->
<script id="shader-texmap-vs-4vec" type="x-shader/x-vertex">
	attribute vec4 aVertexPosition;
	attribute vec4 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uPlayerLightColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec3 veclight;
	
	void main(void) {
		vec4 transformedCoord = uMVMatrix * aVertexPosition;
		gl_Position = uPMatrix * transformedCoord;
		
		fog = 0.5*(1.0 + transformedCoord.w);
		
		vec4 transformedNormal = uMVMatrix * aVertexNormal;
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		light/=1.0 + 4.2*dot(adjustedPos,adjustedPos);		//terms higher than other shaders by sqrt(2) because length
															//of 1,0,0,0 -> 0,1,0,0 (90 deg around world)
		//TODO can process multiple lights using matrix?
		
		veclight=uPlayerLightColor*light;
		
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		veclight+=uReflectorDiffColor*portalLight;
				
		vTextureCoord = vec3( aTextureCoord.st, 1.0 );
	}
</script>

<script id="shader-texmap-vs-4vec-atmos" type="x-shader/x-vertex">
	#define CONST_ITERS 64.0

	attribute vec4 aVertexPosition;
	attribute vec4 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uPlayerLightColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec3 veclight;
	
	void main(void) {
		vec4 transformedCoord = uMVMatrix * aVertexPosition;
		vec4 worldCoord = uMMatrix * aVertexPosition;
		gl_Position = uPMatrix * transformedCoord;
		
		/*
		fog = 0.5*(1.0 + transformedCoord.w);
		//note 1.0 = no fog, 0 = total fog.
		//more complex fog calculation. show that can have radial dependence. not anything like physically correct!
		float airDensityAtObj = exp(-dot(worldCoord.xy,worldCoord.xy));
		fog*=airDensityAtObj; 
		*/
		
		/*
		float dotProd = dot(uCameraWorldPos,worldCoord);
		float maxAng = acos(dotProd);	//angle from camera to object
		float maxAngOverIters = maxAng/CONST_ITERS;
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		float totalPath=0.0;
		float currentAngle;
		vec4 currentPos;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			currentAngle=maxAngOverIters*aa;
			currentPos = uCameraWorldPos*cos(currentAngle)+normalDirection*sin(currentAngle);
			totalPath+=exp(uAtmosContrast*dot(currentPos.xy,currentPos.xy));	//number here affects how different atmos pressure is between extremes
		}
		fog=exp(-totalPath*uAtmosThickness*maxAngOverIters);
		*/
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd);
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float total=0.0;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
		
		
		
		vec4 transformedNormal = uMVMatrix * aVertexNormal;
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		light/=1.0 + 4.2*dot(adjustedPos,adjustedPos);		//terms higher than other shaders by sqrt(2) because length
															//of 1,0,0,0 -> 0,1,0,0 (90 deg around world)
		//TODO can process multiple lights using matrix?
		
		veclight=uPlayerLightColor*light;
		
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		veclight+=uReflectorDiffColor*portalLight;
				
		vTextureCoord = vec3( aTextureCoord.st, 1.0 );
	}
</script>

<script id="shader-texmap-vs-4vec-atmos-v2" type="x-shader/x-vertex">
	attribute vec4 aVertexPosition;
	attribute vec4 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uPlayerLightColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec3 veclight;
	
	void main(void) {
		vec4 transformedCoord = uMVMatrix * aVertexPosition;
		vec4 worldCoord = uMMatrix * aVertexPosition;
		gl_Position = uPMatrix * transformedCoord;
		
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd);
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
		
		
		vec4 transformedNormal = uMVMatrix * aVertexNormal;
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		light/=1.0 + 4.2*dot(adjustedPos,adjustedPos);		//terms higher than other shaders by sqrt(2) because length
															//of 1,0,0,0 -> 0,1,0,0 (90 deg around world)
		//TODO can process multiple lights using matrix?
		
		veclight=uPlayerLightColor*light;
		
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		veclight+=uReflectorDiffColor*portalLight;
				
		vTextureCoord = vec3( aTextureCoord.st, 1.0 );
	}
</script>



<!-- vertex shader with tex coords and 4vector input positions (instead of projected 3vectors.)-->
<script id="shader-texmap-vs-4vec-mapproject" type="x-shader/x-vertex">
	attribute vec4 aVertexPosition;
	attribute vec4 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uPlayerLightColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec3 veclight;
	varying vec4 vVertexPos;
	
	void main(void) {
		vVertexPos = aVertexPosition;	//pass through for atan tex mapping (overriding uv)
	
		vec4 transformedCoord = uMVMatrix * aVertexPosition;
		gl_Position = uPMatrix * transformedCoord;
		
		fog = 0.5*(1.0 + transformedCoord.w);
		
		//vec4 transformedNormal = uMVMatrix * aVertexNormal;	//normals code is buggy
		vec4 transformedNormal = uMVMatrix * aVertexNormal;	
		
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		
		float light = -dot( normalize(adjustedPos), transformedNormal);
		//float light = 1.0;
		
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		light/=1.0 + 4.2*dot(adjustedPos,adjustedPos);		//terms higher than other shaders by sqrt(2) because length
															//of 1,0,0,0 -> 0,1,0,0 (90 deg around world)
		
		veclight=uPlayerLightColor*light;
		
		
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		
		
		float portalLight = dot( uReflectorPos, transformedNormal);
		
		//float portalLight = dot( normalize(uReflectorPos - transformedCoord) , transformedNormal);	//does this make more sense?
		//float portalLight = dot( uReflectorPos - transformedCoord , transformedNormal);
		
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		veclight+=uReflectorDiffColor*portalLight;
				
		vTextureCoord = vec3( aTextureCoord.st, 1.0 );
	}
</script>


<!-- vertex shader with tex coords and 4vector input positions (instead of projected 3vectors.)-->
<script id="shader-texmap-vs-4vec-mapproject-atmos" type="x-shader/x-vertex">
	#define CONST_ITERS 64.0

	attribute vec4 aVertexPosition;
	attribute vec4 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uPlayerLightColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec3 veclight;
	varying vec4 vVertexPos;
	
	void main(void) {
		vVertexPos = aVertexPosition;	//pass through for atan tex mapping (overriding uv)
	
		vec4 transformedCoord = uMVMatrix * aVertexPosition;
		vec4 worldCoord = uMMatrix * aVertexPosition;
		gl_Position = uPMatrix * transformedCoord;
		
		/*
		fog = 0.5*(1.0 + transformedCoord.w);
		//note 1.0 = no fog, 0 = total fog.
		//more complex fog calculation. show that can have radial dependence. not anything like physically correct!
		float airDensityAtObj = exp(-dot(worldCoord.xy,worldCoord.xy));
		fog*=airDensityAtObj; 
		*/
		
		/*
		float dotProd = dot(uCameraWorldPos,worldCoord);
		float maxAng = acos(dotProd);	//angle from camera to object
		float maxAngOverIters = maxAng/CONST_ITERS;
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		float totalPath=0.0;
		float currentAngle;
		vec4 currentPos;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			currentAngle=maxAngOverIters*aa;
			currentPos = uCameraWorldPos*cos(currentAngle)+normalDirection*sin(currentAngle);
			totalPath+=exp(uAtmosContrast*dot(currentPos.xy,currentPos.xy));	//number here affects how different atmos pressure is between extremes
		}
		fog=exp(-totalPath*uAtmosThickness*maxAngOverIters);
		*/
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd);
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float total=0.0;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
		
		
		//vec4 transformedNormal = uMVMatrix * aVertexNormal;	//normals code is buggy
		vec4 transformedNormal = uMVMatrix * aVertexNormal;	
		
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		
		float light = -dot( normalize(adjustedPos), transformedNormal);
		//float light = 1.0;
		
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		light/=1.0 + 4.2*dot(adjustedPos,adjustedPos);		//terms higher than other shaders by sqrt(2) because length
															//of 1,0,0,0 -> 0,1,0,0 (90 deg around world)
		
		veclight=uPlayerLightColor*light;
		
		
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		
		
		float portalLight = dot( uReflectorPos, transformedNormal);
		
		//float portalLight = dot( normalize(uReflectorPos - transformedCoord) , transformedNormal);	//does this make more sense?
		//float portalLight = dot( uReflectorPos - transformedCoord , transformedNormal);
		
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		veclight+=uReflectorDiffColor*portalLight;
				
		vTextureCoord = vec3( aTextureCoord.st, 1.0 );
	}
</script>

<!-- vertex shader with tex coords and 4vector input positions (instead of projected 3vectors.)-->
<script id="shader-texmap-vs-4vec-mapproject-atmos-v2" type="x-shader/x-vertex">
	attribute vec4 aVertexPosition;
	attribute vec4 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uPlayerLightColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec3 veclight;
	varying vec4 vVertexPos;
	
	void main(void) {
		vVertexPos = aVertexPosition;	//pass through for atan tex mapping (overriding uv)
	
		vec4 transformedCoord = uMVMatrix * aVertexPosition;
		vec4 worldCoord = uMMatrix * aVertexPosition;
		gl_Position = uPMatrix * transformedCoord;
		
		/*
		fog = 0.5*(1.0 + transformedCoord.w);
		//note 1.0 = no fog, 0 = total fog.
		//more complex fog calculation. show that can have radial dependence. not anything like physically correct!
		float airDensityAtObj = exp(-dot(worldCoord.xy,worldCoord.xy));
		fog*=airDensityAtObj; 
		*/
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd);
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);	
		
		
		//vec4 transformedNormal = uMVMatrix * aVertexNormal;	//normals code is buggy
		vec4 transformedNormal = uMVMatrix * aVertexNormal;	
		
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		
		float light = -dot( normalize(adjustedPos), transformedNormal);
		//float light = 1.0;
		
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		light/=1.0 + 4.2*dot(adjustedPos,adjustedPos);		//terms higher than other shaders by sqrt(2) because length
															//of 1,0,0,0 -> 0,1,0,0 (90 deg around world)
		
		veclight=uPlayerLightColor*light;
		
		
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		
		
		float portalLight = dot( uReflectorPos, transformedNormal);
		
		//float portalLight = dot( normalize(uReflectorPos - transformedCoord) , transformedNormal);	//does this make more sense?
		//float portalLight = dot( uReflectorPos - transformedCoord , transformedNormal);
		
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		veclight+=uReflectorDiffColor*portalLight;
				
		vTextureCoord = vec3( aTextureCoord.st, 1.0 );
	}
</script>







<!-- vertex shader for water. take 2vec position, calc height, wrap around duocylinder (3vec to 4vec)-->
<script id="shader-texmap-vs-duocylinder-sea" type="x-shader/x-vertex">
	#define CONST_TAU 6.2831853
	
	attribute vec2 aVertexPosition;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform float uTime;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uPlayerLightColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec3 veclight;
	
	varying vec3 vTextureCoord;
	
	void addWaveContribution(in vec2 wavePosIn, inout vec3 wavePosAccum, inout vec3 vDerivativeWRTX, inout vec3 vDerivativeWRTY, float peakiness, vec2 waveCycles){	//waveCycles should be int2
		//wavecycles - number of waves across repeating square in each direction.
		//wavevector relates to this...
		//speed of wave - deep water, speed ~ sqrt(wavelength)
		// wavevector = 2pi/wavelength. wave speed= angularvelocity*wavevector ie (rads/s) / (rads/m)
			//		or speed = frequency*wavelength
			
		// sqrt(wavelength) = angvec * (2pi/wavelength)
		
		//frequency = speed/wavelength ~ sqrt(wavelength)/wavelength = 1/sqrt(wavelength)
		
		//square is 16x16 (TODO make unit square? then can change grid size for fidelity without other messing
		
		//var normalisedGridPos = wavePos
				
		//wavevector is wavecycles * 2PI / square_side_length
		// square_side_length = 1
		
		//wavevector (IIRC direction/wavelength) ~ vec2(n,m), so wavelength = 1/sqrt(n*n+m*m)
		// wavelength = 1/length (wavevector/2PI) = 1/length(wavecycles)
		
		float invWavelength = length(waveCycles);
		
		//since freq and therefore ang vel proportional to 1/invWavelength
		float someConstant = 0.4;	//affects speed of animation
		float freq = someConstant*sqrt(invWavelength);	//<--this why pythagorean tribles not working!
			//unless find triples whose lengths are square! eg 7 24 25, (and 0 1 1, 0 4 4 0 9 9 etc)
		//presumably there is some distribution of wave amplitude with wavelength. for now just try manual terms. IIRC some ratio (since fluid particles circular path)
		//makes pointy waves. therefore pass in "peakiness" - 1 for sharp peak. rolling wheel. 1 revolution in 2pi radii -> pi* peak-to-peak amplitude
		
		//round angfreq so loops? (uTime from 0 to 1 so freq should be integer)
		freq=ceil(freq);
		
		/*
		float phase = CONST_TAU * (uTime*angFreq + dot(waveCycles, wavePosIn.xy));	//TODO should angvel be hardcoded/passed into shader (rather than calc for each vertex)
									//if time is to loop, should ensure waves loop in time - guess by subtle manipulation of angVel (pythagorean triples unrealistic)
		//is this the problem?
		phase=mod(phase,CONST_TAU);	//if works, should mod with 1 before multiplying with CONST_TAU. .... it doesn't work! still glitches!	
		*/
		
		float phase = CONST_TAU* (uTime*freq + dot(waveCycles, wavePosIn));	
		
		float ampl = peakiness/(invWavelength*CONST_TAU);
		wavePosAccum+= ampl*vec3( cos(phase)*waveCycles/invWavelength, sin(phase) );
		
		//add derivative to vDerivativeWRTX, vDerivativeWRTY (TODO combine into matrix?)
		vec3 derivVector = ampl*vec3( -sin(phase)*waveCycles/invWavelength , cos(phase) );	//educated guess TODO proper working
		vDerivativeWRTX += waveCycles.x * derivVector;
		vDerivativeWRTY += waveCycles.y * derivVector;
	}
	
	//ported from tennisBallLoader.js
	vec4 get4vecfrom3vec(in vec3 invec){
		vec2 ang = CONST_TAU * invec.xy;
		float cylr = CONST_TAU * (0.125+ invec.z);
		float sr = sin(cylr);	//todo possible to do this in 1 go? special shader cmmd?
		float cr = cos(cylr);
		return vec4( cr * sin(ang.x), cr * cos(ang.x), sr * sin(ang.y), sr * cos(ang.y) );
	}
	
	void main(void) {
		//1 calc height and normal
		vec3 vDerivativeWRTX = vec3(1./CONST_TAU,0.,0.);
		vec3 vDerivativeWRTY = vec3(0.,1./CONST_TAU,0.);
		
		vec3 vModifiedVertexPosition = vec3( aVertexPosition.xy, 0.02);
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(1.0,9.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(-13.0,2.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(3.0,-7.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(-4.0,5.0));
		
		vec3 surfNorm = normalize(cross(vDerivativeWRTX,vDerivativeWRTY));	//get surface normal by cross product of derivative vectors
				
		//2 convert position and normal to 4vec
		//fake initially to get right vec type
		//vec4 calculatedVertexPosition = vec4(aVertexPosition, 0.,0.);
		vec4 calculatedVertexPosition = get4vecfrom3vec(vModifiedVertexPosition);
		
		//simple way to calc norms - move a little along normal, subtract this from original value, normalise the result.
		//probably can express as a derivative wrt normal movment, then normalise result, but this way is easier.
		vec4 shiftedVertexPosition = get4vecfrom3vec(vModifiedVertexPosition+.001*surfNorm);
		vec4 calculatedVertexNormal = normalize(shiftedVertexPosition - calculatedVertexPosition);
		
		//3 use thse values same as in shader-texmap-vs-4vec
		vec4 transformedCoord = uMVMatrix * calculatedVertexPosition;
		
		gl_Position = uPMatrix * transformedCoord;
		
		fog = 0.5*(1.0 + transformedCoord.w);
		
		vec4 transformedNormal = uMVMatrix * calculatedVertexNormal;
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		light/=1.0 + 4.2*dot(adjustedPos,adjustedPos);		//terms higher than other shaders by sqrt(2) because length
															//of 1,0,0,0 -> 0,1,0,0 (90 deg around world)
		
		veclight=uPlayerLightColor*light;
		
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		veclight+=uReflectorDiffColor*portalLight;
		
		vTextureCoord = vec3( aVertexPosition, 1.0 );	//any point in projected tex??
	}
</script>

<script id="shader-texmap-vs-duocylinder-sea-atmos" type="x-shader/x-vertex">
	#define CONST_TAU 6.2831853
	#define CONST_ITERS 64.0

	attribute vec2 aVertexPosition;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform float uTime;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uPlayerLightColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec3 veclight;
	
	varying vec3 vTextureCoord;
	
	void addWaveContribution(in vec2 wavePosIn, inout vec3 wavePosAccum, inout vec3 vDerivativeWRTX, inout vec3 vDerivativeWRTY, float peakiness, vec2 waveCycles){	//waveCycles should be int2
		//wavecycles - number of waves across repeating square in each direction.
		//wavevector relates to this...
		//speed of wave - deep water, speed ~ sqrt(wavelength)
		// wavevector = 2pi/wavelength. wave speed= angularvelocity*wavevector ie (rads/s) / (rads/m)
			//		or speed = frequency*wavelength
			
		// sqrt(wavelength) = angvec * (2pi/wavelength)
		
		//frequency = speed/wavelength ~ sqrt(wavelength)/wavelength = 1/sqrt(wavelength)
		
		//square is 16x16 (TODO make unit square? then can change grid size for fidelity without other messing
		
		//var normalisedGridPos = wavePos
				
		//wavevector is wavecycles * 2PI / square_side_length
		// square_side_length = 1
		
		//wavevector (IIRC direction/wavelength) ~ vec2(n,m), so wavelength = 1/sqrt(n*n+m*m)
		// wavelength = 1/length (wavevector/2PI) = 1/length(wavecycles)
		
		float invWavelength = length(waveCycles);
		
		//since freq and therefore ang vel proportional to 1/invWavelength
		float someConstant = 0.4;	//affects speed of animation
		float freq = someConstant*sqrt(invWavelength);	//<--this why pythagorean tribles not working!
			//unless find triples whose lengths are square! eg 7 24 25, (and 0 1 1, 0 4 4 0 9 9 etc)
		//presumably there is some distribution of wave amplitude with wavelength. for now just try manual terms. IIRC some ratio (since fluid particles circular path)
		//makes pointy waves. therefore pass in "peakiness" - 1 for sharp peak. rolling wheel. 1 revolution in 2pi radii -> pi* peak-to-peak amplitude
		
		//round angfreq so loops? (uTime from 0 to 1 so freq should be integer)
		freq=ceil(freq);
		
		/*
		float phase = CONST_TAU * (uTime*angFreq + dot(waveCycles, wavePosIn.xy));	//TODO should angvel be hardcoded/passed into shader (rather than calc for each vertex)
									//if time is to loop, should ensure waves loop in time - guess by subtle manipulation of angVel (pythagorean triples unrealistic)
		//is this the problem?
		phase=mod(phase,CONST_TAU);	//if works, should mod with 1 before multiplying with CONST_TAU. .... it doesn't work! still glitches!	
		*/
		
		float phase = CONST_TAU* (uTime*freq + dot(waveCycles, wavePosIn));	
		
		float ampl = peakiness/(invWavelength*CONST_TAU);
		wavePosAccum+= ampl*vec3( cos(phase)*waveCycles/invWavelength, sin(phase) );
		
		//add derivative to vDerivativeWRTX, vDerivativeWRTY (TODO combine into matrix?)
		vec3 derivVector = ampl*vec3( -sin(phase)*waveCycles/invWavelength , cos(phase) );	//educated guess TODO proper working
		vDerivativeWRTX += waveCycles.x * derivVector;
		vDerivativeWRTY += waveCycles.y * derivVector;
	}
	
	//ported from tennisBallLoader.js
	vec4 get4vecfrom3vec(in vec3 invec){
		vec2 ang = CONST_TAU * invec.xy;
		float cylr = CONST_TAU * (0.125+ invec.z);
		float sr = sin(cylr);	//todo possible to do this in 1 go? special shader cmmd?
		float cr = cos(cylr);
		return vec4( cr * sin(ang.x), cr * cos(ang.x), sr * sin(ang.y), sr * cos(ang.y) );
	}
	
	void main(void) {
		//1 calc height and normal
		vec3 vDerivativeWRTX = vec3(1./CONST_TAU,0.,0.);
		vec3 vDerivativeWRTY = vec3(0.,1./CONST_TAU,0.);
		
		vec3 vModifiedVertexPosition = vec3( aVertexPosition.xy, 0.02);
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(1.0,9.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(-13.0,2.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(3.0,-7.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(-4.0,5.0));
		
		vec3 surfNorm = normalize(cross(vDerivativeWRTX,vDerivativeWRTY));	//get surface normal by cross product of derivative vectors
				
		//2 convert position and normal to 4vec
		//fake initially to get right vec type
		//vec4 calculatedVertexPosition = vec4(aVertexPosition, 0.,0.);
		vec4 calculatedVertexPosition = get4vecfrom3vec(vModifiedVertexPosition);
		
		//simple way to calc norms - move a little along normal, subtract this from original value, normalise the result.
		//probably can express as a derivative wrt normal movment, then normalise result, but this way is easier.
		vec4 shiftedVertexPosition = get4vecfrom3vec(vModifiedVertexPosition+.001*surfNorm);
		vec4 calculatedVertexNormal = normalize(shiftedVertexPosition - calculatedVertexPosition);
		
		//3 use thse values same as in shader-texmap-vs-4vec
		vec4 transformedCoord = uMVMatrix * calculatedVertexPosition;
		vec4 worldCoord = uMMatrix * calculatedVertexPosition;
		gl_Position = uPMatrix * transformedCoord;
		
		/*
		fog = 0.5*(1.0 + transformedCoord.w);
		//note 1.0 = no fog, 0 = total fog.
		//more complex fog calculation. show that can have radial dependence. not anything like physically correct!
		float airDensityAtObj = exp(-dot(worldCoord.xy,worldCoord.xy));
		fog*=airDensityAtObj; 
		*/
		
		/*
		float dotProd = dot(uCameraWorldPos,worldCoord);
		float maxAng = acos(dotProd);	//angle from camera to object
		float maxAngOverIters = maxAng/CONST_ITERS;
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		float totalPath=0.0;
		float currentAngle;
		vec4 currentPos;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			currentAngle=maxAngOverIters*aa;
			currentPos = uCameraWorldPos*cos(currentAngle)+normalDirection*sin(currentAngle);
			totalPath+=exp(uAtmosContrast*dot(currentPos.xy,currentPos.xy));	//number here affects how different atmos pressure is between extremes
		}
		fog=exp(-totalPath*uAtmosThickness*maxAngOverIters);
		*/
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd);
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float total=0.0;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
				
		vec4 transformedNormal = uMVMatrix * calculatedVertexNormal;
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		light/=1.0 + 4.2*dot(adjustedPos,adjustedPos);		//terms higher than other shaders by sqrt(2) because length
															//of 1,0,0,0 -> 0,1,0,0 (90 deg around world)
		
		veclight=uPlayerLightColor*light;
		
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		veclight+=uReflectorDiffColor*portalLight;
		
		vTextureCoord = vec3( aVertexPosition, 1.0 );	//any point in projected tex??
	}
</script>

<script id="shader-texmap-vs-duocylinder-sea-atmos-v2" type="x-shader/x-vertex">
	#define CONST_TAU 6.2831853

	attribute vec2 aVertexPosition;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform float uTime;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uPlayerLightColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec3 veclight;
	
	varying vec3 vTextureCoord;
	
	void addWaveContribution(in vec2 wavePosIn, inout vec3 wavePosAccum, inout vec3 vDerivativeWRTX, inout vec3 vDerivativeWRTY, float peakiness, vec2 waveCycles){	//waveCycles should be int2
		//wavecycles - number of waves across repeating square in each direction.
		//wavevector relates to this...
		//speed of wave - deep water, speed ~ sqrt(wavelength)
		// wavevector = 2pi/wavelength. wave speed= angularvelocity*wavevector ie (rads/s) / (rads/m)
			//		or speed = frequency*wavelength
			
		// sqrt(wavelength) = angvec * (2pi/wavelength)
		
		//frequency = speed/wavelength ~ sqrt(wavelength)/wavelength = 1/sqrt(wavelength)
		
		//square is 16x16 (TODO make unit square? then can change grid size for fidelity without other messing
		
		//var normalisedGridPos = wavePos
				
		//wavevector is wavecycles * 2PI / square_side_length
		// square_side_length = 1
		
		//wavevector (IIRC direction/wavelength) ~ vec2(n,m), so wavelength = 1/sqrt(n*n+m*m)
		// wavelength = 1/length (wavevector/2PI) = 1/length(wavecycles)
		
		float invWavelength = length(waveCycles);
		
		//since freq and therefore ang vel proportional to 1/invWavelength
		float someConstant = 0.4;	//affects speed of animation
		float freq = someConstant*sqrt(invWavelength);	//<--this why pythagorean tribles not working!
			//unless find triples whose lengths are square! eg 7 24 25, (and 0 1 1, 0 4 4 0 9 9 etc)
		//presumably there is some distribution of wave amplitude with wavelength. for now just try manual terms. IIRC some ratio (since fluid particles circular path)
		//makes pointy waves. therefore pass in "peakiness" - 1 for sharp peak. rolling wheel. 1 revolution in 2pi radii -> pi* peak-to-peak amplitude
		
		//round angfreq so loops? (uTime from 0 to 1 so freq should be integer)
		freq=ceil(freq);
		
		/*
		float phase = CONST_TAU * (uTime*angFreq + dot(waveCycles, wavePosIn.xy));	//TODO should angvel be hardcoded/passed into shader (rather than calc for each vertex)
									//if time is to loop, should ensure waves loop in time - guess by subtle manipulation of angVel (pythagorean triples unrealistic)
		//is this the problem?
		phase=mod(phase,CONST_TAU);	//if works, should mod with 1 before multiplying with CONST_TAU. .... it doesn't work! still glitches!	
		*/
		
		float phase = CONST_TAU* (uTime*freq + dot(waveCycles, wavePosIn));	
		
		float ampl = peakiness/(invWavelength*CONST_TAU);
		wavePosAccum+= ampl*vec3( cos(phase)*waveCycles/invWavelength, sin(phase) );
		
		//add derivative to vDerivativeWRTX, vDerivativeWRTY (TODO combine into matrix?)
		vec3 derivVector = ampl*vec3( -sin(phase)*waveCycles/invWavelength , cos(phase) );	//educated guess TODO proper working
		vDerivativeWRTX += waveCycles.x * derivVector;
		vDerivativeWRTY += waveCycles.y * derivVector;
	}
	
	//ported from tennisBallLoader.js
	vec4 get4vecfrom3vec(in vec3 invec){
		vec2 ang = CONST_TAU * invec.xy;
		float cylr = CONST_TAU * (0.125+ invec.z);
		float sr = sin(cylr);	//todo possible to do this in 1 go? special shader cmmd?
		float cr = cos(cylr);
		return vec4( cr * sin(ang.x), cr * cos(ang.x), sr * sin(ang.y), sr * cos(ang.y) );
	}
	
	void main(void) {
		//1 calc height and normal
		vec3 vDerivativeWRTX = vec3(1./CONST_TAU,0.,0.);
		vec3 vDerivativeWRTY = vec3(0.,1./CONST_TAU,0.);
		
		vec3 vModifiedVertexPosition = vec3( aVertexPosition.xy, 0.02);
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(1.0,9.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(-13.0,2.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(3.0,-7.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(-4.0,5.0));
		
		vec3 surfNorm = normalize(cross(vDerivativeWRTX,vDerivativeWRTY));	//get surface normal by cross product of derivative vectors
				
		//2 convert position and normal to 4vec
		//fake initially to get right vec type
		//vec4 calculatedVertexPosition = vec4(aVertexPosition, 0.,0.);
		vec4 calculatedVertexPosition = get4vecfrom3vec(vModifiedVertexPosition);
		
		//simple way to calc norms - move a little along normal, subtract this from original value, normalise the result.
		//probably can express as a derivative wrt normal movment, then normalise result, but this way is easier.
		vec4 shiftedVertexPosition = get4vecfrom3vec(vModifiedVertexPosition+.001*surfNorm);
		vec4 calculatedVertexNormal = normalize(shiftedVertexPosition - calculatedVertexPosition);
		
		//3 use thse values same as in shader-texmap-vs-4vec
		vec4 transformedCoord = uMVMatrix * calculatedVertexPosition;
		vec4 worldCoord = uMMatrix * calculatedVertexPosition;
		gl_Position = uPMatrix * transformedCoord;
		
		/*
		fog = 0.5*(1.0 + transformedCoord.w);
		//note 1.0 = no fog, 0 = total fog.
		//more complex fog calculation. show that can have radial dependence. not anything like physically correct!
		float airDensityAtObj = exp(-dot(worldCoord.xy,worldCoord.xy));
		fog*=airDensityAtObj; 
		*/
		
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd);
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
		
		
		vec4 transformedNormal = uMVMatrix * calculatedVertexNormal;
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		light/=1.0 + 4.2*dot(adjustedPos,adjustedPos);		//terms higher than other shaders by sqrt(2) because length
															//of 1,0,0,0 -> 0,1,0,0 (90 deg around world)
		
		veclight=uPlayerLightColor*light;
		
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		veclight+=uReflectorDiffColor*portalLight;
		
		vTextureCoord = vec3( aVertexPosition, 1.0 );	//any point in projected tex??
	}
</script>


<!-- simple cubemap pix shader -->
<script id="shader-cubemap-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform samplerCube uSampler;
	varying vec3 vPos;
	varying float fog;
	uniform vec4 uColor;	//TODO remove? (should be white, but useful to tint for debug/ coloured reflector)
	uniform vec4 uFogColor;
	
	void main(void) {
		//gl_FragColor = uColor*textureCube(uSampler, vPos);	//TODO use this (get rid of fog)
		vec4 preGammaFragColor = vec4( vec3(fog), 1.0)*uColor*pow(textureCube(uSampler, vPos),vec4(2.2)) + (1.0-fog)*uFogColor;	//todo render cubemap with gamma 1

		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
	}
</script>
<!-- vertex shader -->
<script id="shader-cubemap-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	varying vec3 vPos;
	varying float fog;	//TODO remove (fog should be applied at cubemap generation (unless fog is exponential decay)
	uniform vec3 uModelScale;
	uniform mat4 uPosShiftMat;
	uniform float uPolarity;

	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));	//project 3d object onto 3sphere
																//can avoid this by inputting 4vector positions *...
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		fog = 0.5*(1.0 + transformedCoord.w);
	
		//gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); // *... or can just use 1.0 without normalising? TODO try.
		gl_Position = uPMatrix * transformedCoord;
		
		vPos = uPolarity * (uPosShiftMat*aVertexPositionNormalized).xyz;
	}
</script>


<script id="shader-cubemap-vertproj-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	varying vec3 vPos;
	varying float fog;	//TODO remove (fog should be applied at cubemap generation (unless fog is exponential decay)
	uniform vec3 uModelScale;
	uniform mat4 uPosShiftMat;
	uniform vec3 uCentrePosScaled;	//this is position of cubemap centre point in unprojected model space
	uniform float uPolarity;
	
	void main(void) {
		float csq = dot(uCentrePosScaled,uCentrePosScaled);
		float cdotp = dot(uCentrePosScaled, -aVertexPosition);
		float a = pow((1.0-csq)+cdotp*cdotp, 0.5) - cdotp;
		vec3 scaledVertexPosition = aVertexPosition*a;
	
		vec4 aVertexPositionNormalized = normalize(vec4( uModelScale*(scaledVertexPosition-uCentrePosScaled), 1.0));	
		
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		fog = 0.5*(1.0 + transformedCoord.w);
	
		gl_Position = uPMatrix * transformedCoord;
		
		vPos = uPolarity * (uPosShiftMat*aVertexPositionNormalized).xyz;
	}
</script>


<script id="shader-cubemap-vertproj-vs-atmos" type="x-shader/x-vertex">
	#define CONST_ITERS 64.0
	
	attribute vec3 aVertexPosition;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	varying vec3 vPos;
	varying float fog;	//TODO remove (fog should be applied at cubemap generation (unless fog is exponential decay)
	uniform vec3 uModelScale;
	uniform mat4 uPosShiftMat;
	uniform vec3 uCentrePosScaled;	//this is position of cubemap centre point in unprojected model space
	uniform float uPolarity;
	
	void main(void) {
		float csq = dot(uCentrePosScaled,uCentrePosScaled);
		float cdotp = dot(uCentrePosScaled, -aVertexPosition);
		float a = pow((1.0-csq)+cdotp*cdotp, 0.5) - cdotp;
		vec3 scaledVertexPosition = aVertexPosition*a;
	
		vec4 aVertexPositionNormalized = normalize(vec4( uModelScale*(scaledVertexPosition-uCentrePosScaled), 1.0));	
		
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;

		/*
		fog = 0.5*(1.0 + transformedCoord.w);
		//note 1.0 = no fog, 0 = total fog.
		//more complex fog calculation. show that can have radial dependence. not anything like physically correct!
		float airDensityAtObj = exp(-dot(worldCoord.xy,worldCoord.xy));
		fog*=airDensityAtObj; 
		*/
		
		//although this is used for "per pixel" version, currently calculating fog per vertex.
		
		/*
		float dotProd = dot(uCameraWorldPos,worldCoord);
		float maxAng = acos(dotProd*0.999);	//angle from camera to object
		float maxAngOverIters = maxAng/CONST_ITERS;
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		float totalPath=0.0;
		float currentAngle;
		vec4 currentPos;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			currentAngle=maxAngOverIters*aa;
			currentPos = uCameraWorldPos*cos(currentAngle)+normalDirection*sin(currentAngle);
			totalPath+=exp(uAtmosContrast*dot(currentPos.xy,currentPos.xy));	//number here affects how different atmos pressure is between extremes
		}
		fog=exp(-totalPath*uAtmosThickness*maxAngOverIters);
		*/
	
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd*0.999);
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float total=0.0;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
	
		gl_Position = uPMatrix * transformedCoord;
		
		vPos = uPolarity * (uPosShiftMat*aVertexPositionNormalized).xyz;
	}
</script>


<script id="shader-cubemap-vertproj-vs-atmos-v2" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	varying vec3 vPos;
	varying float fog;	//TODO remove (fog should be applied at cubemap generation (unless fog is exponential decay)
	uniform vec3 uModelScale;
	uniform mat4 uPosShiftMat;
	uniform vec3 uCentrePosScaled;	//this is position of cubemap centre point in unprojected model space
	uniform float uPolarity;
	
	void main(void) {
		float csq = dot(uCentrePosScaled,uCentrePosScaled);
		float cdotp = dot(uCentrePosScaled, -aVertexPosition);
		float a = pow((1.0-csq)+cdotp*cdotp, 0.5) - cdotp;
		vec3 scaledVertexPosition = aVertexPosition*a;
	
		vec4 aVertexPositionNormalized = normalize(vec4( uModelScale*(scaledVertexPosition-uCentrePosScaled), 1.0));	
		
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;

		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd*0.999);
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
		
	
		gl_Position = uPMatrix * transformedCoord;
		
		vPos = uPolarity * (uPosShiftMat*aVertexPositionNormalized).xyz;
	}
</script>




<script type="text/javascript" src="js/main.js"></script>




</head>



<body onload="init()">
<div id="info">3-sphere visualised in WebGL demo. Arrow keys, QE, click+drag mouse to rotate. WASD, space/ctrl to translate.<a href="https://github.com/filbs111/3sphere-explorer" target="_blank">https://github.com/filbs111/3sphere-explorer</a></div>
<div id="info2"></div>
		
<!--<svg style="position:absolute;background:#0000;left:780px;top:330px" height="200" width="200">
  <circle cx="100" cy="100" r="80" stroke="yellow" stroke-width="2" fill="none" />
  <circle cx="100" cy="100" r="5" stroke="yellow" stroke-width="2" fill="none" />
</svg>-->
<canvas id="mycanvas" width="0" height="0">CANVAS TO GO HERE</canvas>


</body>


</html>