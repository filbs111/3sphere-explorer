<!DOCTYPE html>
<html>

<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<title>3-sphere explorer</title>

<style>
	body {
		margin: 0px;
		overflow: hidden;
	}

	#info {
		position: absolute;
		top: 0px; width: 100%;
		padding: 20px;
		color: white;
		text-align: center;
	}
	
	#info2 {
		position: absolute;
		top: 90%; width: 100%;
		padding: 20px;
		color: red;
		text-align: left;
		background: #0007;
		font-family: 'Lucida Console', Monaco, monospace;
		font-weight: bold;
	}
	
	#info a:link {
				color: white;
	}
		
	#info a:visited {
		color: white;
	}
</style>

<script type="text/javascript" src="lib/dat.gui.min.js"></script>
<script type="text/javascript" src="lib/stats.min.js"></script>
<script type="text/javascript" src="lib/perlin.js"></script><!-- https://github.com/josephg/noisejs/blob/master/perlin.js -->
<script type="text/javascript" src="lib/gl-matrix-min.js"></script>
<script type="text/javascript" src="utils/matfuncs.js"></script>
<script type="text/javascript" src="utils/fullscreen.js"></script>
<script type="text/javascript" src="utils/webgl_utils.js"></script>
<script type="text/javascript" src="utils/keys.js"></script>
<script type="text/javascript" src="utils/gamepad_settings.js"></script>
<script type="text/javascript" src="utils/multisound.js"></script>
<script type="text/javascript" src="data/sphere.js"></script>
<script type="text/javascript" src="data/quad.js"></script>
<script type="text/javascript" src="data/levelCubeData.js"></script>
<script type="text/javascript" src="data/explodingCubeData.js"></script>
<script type="text/javascript" src="data/tennisBall.js"></script>
<script type="text/javascript" src="data/grid1.obj.json.min"></script>
<script type="text/javascript" src="data/terrain/untitled64tri-deduped-wrap.obj.json.min"></script>
<script type="text/javascript" src="data/gridData.js"></script>
<script type="text/javascript" src="data/proceduralTerrain.js"></script>
<script type="text/javascript" src="data/seaheight.js"></script>
<script type="text/javascript" src="data/duocylinderBoxInfo.js"></script>
<script type="text/javascript" src="data/tennisBallLoader.js"></script>
<script type="text/javascript" src="data/cube-frame-a1-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/cube-frame-a2-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/octohedron-nosubdiv-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/octohedron-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/tetra-frame.obj.json"></script>
<script type="text/javascript" src="data/tetra-frame1-subdiv.obj.json"></script>
<script type="text/javascript" src="data/dodecahedron-frame-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/wt_teapot-trimmed.obj.json"></script>
<!--<script type="text/javascript" src="data/sship-pointyc-tidy1-triang.obj.json"></script>-->
<script type="text/javascript" src="data/dirLight/sship-pointyc-tidy1-uv5-YZ-p04scale.obj.json""></script>
<script type="text/javascript" src="data/guncyl.obj.json"></script>
<script type="text/javascript" src="data/icoball.obj.json"></script>
<script type="text/javascript" src="data/hyperboloidData.js"></script>
<script type="text/javascript" src="data/cells.js"></script>
<script type="text/javascript" src="data/ringCells.js"></script>
<script type="text/javascript" src="data/voxterrain.js"></script>


<!-- vertex shader -->
<script id="shader-fullscreen-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	varying vec2 vTextureCoord;
	
	void main(void) {
		gl_Position = vec4(aVertexPosition, 1.0);		
		vTextureCoord = aVertexPosition.xy*0.5 + 0.5;
	}
</script>

<!-- simple texture mapped pix shader -->
<script id="shader-fullscreen-fs" type="x-shader/x-fragment">
	precision mediump float;
	
	varying vec2 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec2 uInvSize;
	
	void main(void) {
		//gl_FragColor = texture2D(uSampler, vTextureCoord);
		//gl_FragColor = vec4(vec3(texture2D(uSampler, vTextureCoord).y),1.0);	//grayscale by just take green channel
		
		vec4 luma = vec4(0.299,0.587,0.144,0.0);
		
		vec4 MIDv4 = texture2D(uSampler, vTextureCoord);
		float MID = dot(luma,MIDv4);
		float NW = dot(luma, texture2D(uSampler, vTextureCoord + uInvSize*vec2(-1.0,-1.0)));
		float NE = dot(luma, texture2D(uSampler, vTextureCoord + uInvSize*vec2(1.0,-1.0)));
		float SW = dot(luma, texture2D(uSampler, vTextureCoord + uInvSize*vec2(-1.0,1.0)));
		float SE = dot(luma, texture2D(uSampler, vTextureCoord + uInvSize*vec2(1.0,1.0)));
		
		//calculate normal to gradient
		vec3 dir = 1.5*normalize(vec3( ((SW+SE) - (NW+NE)), ((SW+NW) - (SE+NE)) , 0.25));	//last part a fudge factor so small xy remains after normalisation
					//1.5 is a fudge factor to extend sample position
					
					//TODO should NW, NE etc samples be used in final result if in desired direction?)
				
		vec4 avg = 0.333*(texture2D(uSampler, vTextureCoord + uInvSize*dir.xy) + texture2D(uSampler, vTextureCoord - uInvSize*dir.xy) + MIDv4);
		
		gl_FragColor = avg;
		//gl_FragColor = vec4(vec3(avg.y),1.0);	//grayscale by just take green channel
	}
</script>

<!-- simple texture mapped pix shader with fisheye effect-->
<script id="shader-fullscreen-fs-fisheye" type="x-shader/x-fragment">
	precision mediump float;
	
	varying vec2 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec2 uInvSize;
	uniform vec2 uInvF;

	//WIP
	//TODO increase size of input texture so that doesn't go out of range after barrel distortion. (can see texture clamp around edges currently)
	//TODO use fxaa
	
	void main(void) {
		vec2 oversize = vec2(1.6,1.6);	//TODO combo this with something else and pass in as uniform?
										//using this as simple bodge - increase fx,fy of rendered texture (that will use in this shader), reverse scaling here. could be much more efficient (doing in frag shader is worst case!). also hardcoded value is suitable only for some power, fov... (diagonal FOV ?)
										//for small FOV, oversize = 1.
										//for value (assumed that same for fx,fy - maybe approximation) 1.6, means ~2.56x more pixels drawn, assuming scale up texture so that detail in centre part of screen is 1:1 in final output. this means a big performance impact, so, if want to keep big FOV, should looks for other method (2 or 4 textures, or cubemap, or vertex shader version (distort meshes in vertex shader - would require sufficient tesselation- project for webgl2?)). similar optimisations apply to rendering view through portal.
										
										//fisheye also reduces sensation of speed
										//todo combine with FXAA
										
		float uVarOne = -0.026;	//TODO USE UNIFORM. +ve = pincushion, -ve = barrel. from webgl-wideangle project. -0.125 for stereographic projection. use something smaller for more subtle effect (since not viewing screen from infinity, only using 1 camera)
		
		vec2 modifiedTextureCoord = 4.*(vTextureCoord - 0.5)/(oversize*uInvF);	//TODO modify in vert shader.
		
		//gl_FragColor = texture2DProj(uSampler, vec3(1.0,1.0,2.0)*(2.0 + uVarOne*dot(modifiedTextureCoord,modifiedTextureCoord)) + vec3(uInvF.st*modifiedTextureCoord.st, 0.0));

		vec3 centrePoint = (2.0 + uVarOne*dot(modifiedTextureCoord,modifiedTextureCoord)) + vec3(uInvF.st*modifiedTextureCoord.st, 0.0);
		vec4 MIDv4 = texture2DProj(uSampler, vec3(1.0,1.0,2.0)*centrePoint );
		
		gl_FragColor = MIDv4;
	}
</script>



<script id="shader-fullscreen-fs-bennybox-lite" type="x-shader/x-fragment">
	precision mediump float;
	
	varying vec2 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec2 uInvSize;
	
	void main(void) {	
		float FXAA_SPAN_MAX = 8.0;
		float FXAA_REDUCE_MIN = 1.0/128.0;
		float FXAA_REDUCE_MUL = 1.0/8.0;
	
		vec4 luma = vec4(0.299,0.587,0.144,0.0);
		
		vec4 MIDv4 = texture2D(uSampler, vTextureCoord);
		float MID = dot(luma,MIDv4);
		float NW = dot(luma, texture2D(uSampler, vTextureCoord + uInvSize*vec2(-1.0,-1.0)));
		float NE = dot(luma, texture2D(uSampler, vTextureCoord + uInvSize*vec2(1.0,-1.0)));
		float SW = dot(luma, texture2D(uSampler, vTextureCoord + uInvSize*vec2(-1.0,1.0)));
		float SE = dot(luma, texture2D(uSampler, vTextureCoord + uInvSize*vec2(1.0,1.0)));
		
		//calculate normal to gradient
		vec2 dir;
		dir.x = (SW+SE) - (NW+NE);
		dir.y = (SW+NW) - (SE+NE);
					
		float dirReduce = max((NW+NE+SW+SE)*FXAA_REDUCE_MUL*0.25 , FXAA_REDUCE_MIN);
		float inverseDirAdjustment = 1.0/(min(abs(dir.x),abs(dir.y)) + dirReduce);
		
		dir = max(vec2(-1.0,-1.0)*FXAA_SPAN_MAX , min( vec2(1.0,1.0)*FXAA_SPAN_MAX , dir*inverseDirAdjustment));
		dir = dir*0.5;	//like result2 from video
		//now dir is multiplied by thirds, so guess could simplify above code.
		//missing test for extreme result2 values, sampling for result1. 
		
		vec4 avg = 0.333*(texture2D(uSampler, vTextureCoord + uInvSize*dir.xy) + texture2D(uSampler, vTextureCoord - uInvSize*dir.xy) + MIDv4);
		
		gl_FragColor = avg;
		//gl_FragColor = vec4(vec3(avg.y),1.0);	//grayscale by just take green channel
		//gl_FragColor = vec4(vec3(dot(luma,avg)),1.0);	//grayscale
	}
</script>


<script id="shader-fullscreen-fs-bennybox" type="x-shader/x-fragment">
	precision mediump float;
	
	varying vec2 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec2 uInvSize;
	
	void main(void) {	
		float FXAA_SPAN_MAX = 8.0;
		float FXAA_REDUCE_MIN = 1.0/128.0;
		float FXAA_REDUCE_MUL = 1.0/8.0;
	
		vec4 luma = vec4(0.299,0.587,0.144,0.0);
		
		vec4 MIDv4 = texture2D(uSampler, vTextureCoord);
		float MID = dot(luma,MIDv4);
		float NW = dot(luma, texture2D(uSampler, vTextureCoord + uInvSize*vec2(-1.0,-1.0)));
		float NE = dot(luma, texture2D(uSampler, vTextureCoord + uInvSize*vec2(1.0,-1.0)));
		float SW = dot(luma, texture2D(uSampler, vTextureCoord + uInvSize*vec2(-1.0,1.0)));
		float SE = dot(luma, texture2D(uSampler, vTextureCoord + uInvSize*vec2(1.0,1.0)));
		
		//calculate normal to gradient
		vec2 dir;
		dir.x = (SW+SE) - (NW+NE);
		dir.y = (SW+NW) - (SE+NE);
					
		float dirReduce = max((NW+NE+SW+SE)*FXAA_REDUCE_MUL*0.25 , FXAA_REDUCE_MIN);
		float inverseDirAdjustment = 1.0/(min(abs(dir.x),abs(dir.y)) + dirReduce);
		
		dir = max(vec2(-1.0,-1.0)*FXAA_SPAN_MAX , min( vec2(1.0,1.0)*FXAA_SPAN_MAX , dir*inverseDirAdjustment));
		
		vec4 result1 = 0.5*(texture2D(uSampler, vTextureCoord + uInvSize*(0.16667*dir.xy)) + texture2D(uSampler, vTextureCoord - uInvSize*(0.16667*dir.xy)));
		
		vec4 result2 = result1*0.5 + 0.25*(texture2D(uSampler, vTextureCoord + uInvSize*(0.5*dir.xy)) + texture2D(uSampler, vTextureCoord - uInvSize*(0.5*dir.xy)));
		
		float lumaM = dot(luma, MIDv4);
		float lumaMin = min(lumaM, min(min(NW,NE), min(SW,SE)));
		float lumaMax = max(lumaM, max(max(NW,NE), max(SW,SE)));
		float lumaResult2 = dot(luma, result2);
		if (lumaResult2 < lumaMin || lumaResult2> lumaMax){
			gl_FragColor = result1;
		}else{
			gl_FragColor = result2;
		}		
	}
</script>


<!-- tex mapped decal pix shader -->
<script id="shader-decal-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	
	void main(void) {
		gl_FragColor = uColor*texture2DProj(uSampler, vTextureCoord);	//TODO don't use projective texture if not necessary! (eg for quads)
		//gl_FragColor = uColor;
	}
</script>

<!-- vertex shader with tex coords -->
<script id="shader-decal-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec3 uModelScale;
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		gl_Position = uPMatrix * transformedCoord;
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>

<!-- simple pix shader -->
<script id="shader-simple-fs" type="x-shader/x-fragment">
	//#extension GL_EXT_frag_depth : enable

	precision mediump float;
	uniform vec4 uColor;
	uniform vec3 uEmitColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying float light;
	
	void main(void) {
		gl_FragColor = vec4( fog*(( vec3(light) + uFogColor.xyz )*uColor.xyz + uEmitColor), 1.0) + (1.0-fog)*uFogColor;
	}
</script>
<!-- vertex shader -->
<!-- note that taking in 3vector for vertex positions since generally objects are significantly smaller than the 3-sphere radius, so can project them onto unit 3sphere
(set w=1 and normalise to r=1) or j ust set w=1. --> 
<!-- if normalisation is used, i expect will be more efficient to generate 4-vector vertiex buffers and pass those in -->
<!-- mvmatrix will be an SO4 matrix. pmatrix will try a standard projection matrix -->
<!-- possibly want to output additional varying to pass some depth variable -->
<!-- TODO use textured shader to check that that interpolates in sensible way (ie perspective projection observed for rectangles). -->
<script id="shader-simple-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying float fog;
	uniform vec3 uModelScale;
	varying float light;
			
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		gl_Position = uPMatrix * transformedCoord;

		vec4 transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.1 + 5.0*dot(adjustedPos,adjustedPos);	//1st num some const to ensure light doesn't go inf at short dist
													//guess maybe similar to some gaussian light source
		fog = 0.5*(1.0 + transformedCoord.w);
	}
</script>

<!-- tex mapped pix shader -->
<script id="shader-texmap-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying vec3 veclight;
	
	void main(void) {
		//gl_FragColor = uColor*texture2D(uSampler, vTextureCoord);
		
		vec4 preGammaFragColor = vec4( fog*( veclight + uFogColor.xyz ), 1.0)*uColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		
		//tone mapping
		preGammaFragColor = preGammaFragColor/(1.+preGammaFragColor);
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		//gl_FragColor = vec4( pow(preGammaFragColor.r,0.455), pow(preGammaFragColor.g,0.455), pow(preGammaFragColor.b,0.455), pow(preGammaFragColor.a,0.455));
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
	}
</script>

<!-- triplanar texture mapping for voxel terrain -->
<script id="shader-texmap-triplanar-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying vec3 veclight;
	varying vec3 vPos;		//3vector position (before mapping onto duocyinder)
	varying vec3 vTexAmounts;
	
	void main(void) {		
		float texOffset = 0.5;
		vec3 texColor = mat3(texture2D(uSampler, vec2(vPos.y, vPos.z)).xyz, texture2D(uSampler, vec2(vPos.x, vPos.z + texOffset )).xyz, texture2D(uSampler, vec2(vPos.x + texOffset, vPos.y + texOffset )).xyz) * vTexAmounts;
		
		vec4 preGammaFragColor = vec4( texColor*fog*( veclight + uFogColor.xyz ), 1.0)*uColor + (1.0-fog)*uFogColor;
		
		//tone mapping
		preGammaFragColor = preGammaFragColor/(1.+preGammaFragColor);	
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		//gl_FragColor = vec4( pow(preGammaFragColor.r,0.455), pow(preGammaFragColor.g,0.455), pow(preGammaFragColor.b,0.455), pow(preGammaFragColor.a,0.455));
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
	}
</script>

<!-- tex mapped pix shader -->
<script id="shader-texmap-fs-mapproject" type="x-shader/x-fragment">
	#define CONST_TAU 6.2831853
	#define CONST_REPS 16.0
	
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying vec3 veclight;
	varying vec4 vVertexPos;
	
	void main(void) {
		//gl_FragColor = uColor*texture2D(uSampler, vTextureCoord);
	
		vec2 newTexCoord = vec2( atan(vVertexPos.x,vVertexPos.y)*CONST_REPS/CONST_TAU, atan(vVertexPos.z,vVertexPos.w)*CONST_REPS/CONST_TAU);
		
		//gl_FragColor = vec4( fog*( veclight + uFogColor.xyz ), 1.0)*uColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		vec4 preGammaFragColor = vec4( fog*( veclight + uFogColor.xyz ), 1.0)*uColor*texture2D(uSampler, newTexCoord) + (1.0-fog)*uFogColor;
		
		//tone mapping
		preGammaFragColor = preGammaFragColor/(1.+preGammaFragColor);	
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		//gl_FragColor = vec4( pow(preGammaFragColor.r,0.455), pow(preGammaFragColor.g,0.455), pow(preGammaFragColor.b,0.455), pow(preGammaFragColor.a,0.455));
		
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
	}
</script>



<!-- no tex pix shader -->
<script id="shader-flat-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying vec3 veclight;
	
	void main(void) {
		gl_FragColor = vec4( fog*( veclight + uFogColor.xyz ), 1.0)*uColor + (1.0-fog)*uFogColor;
		//gl_FragColor = vec4(1.,0.,0.,1.);
		//gl_FragColor = uColor;
		gl_FragColor.a =1.0;
	}
</script>

<!-- per pixel lighting -->
<!-- expect can make this more efficient -->
<script id="shader-perpixel-fs" type="x-shader/x-fragment">
	//#extension GL_EXT_frag_depth : enable

	precision mediump float;
	uniform vec4 uColor;
	uniform vec3 uEmitColor;
	uniform vec4 uFogColor;
	varying float fog;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	
	void main(void) {
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.1 + 5.0*dot(adjustedPos,adjustedPos);	//1st num some const to ensure light doesn't go inf at short dist
													//guess maybe similar to some gaussian light source
		gl_FragColor = vec4( fog*(( vec3(light) + uFogColor.xyz )*uColor.xyz + uEmitColor), 1.0) + (1.0-fog)*uFogColor;
	}
</script>
<script id="shader-perpixel-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uModelScale;
	varying float fog;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		
		fog = 0.5*(1.0 + transformedCoord.w);
	}
</script>

<!-- discard fragments inside reflector (when rendering cubemap view from inside reflector -->
<script id="shader-perpixel-discard-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform vec4 uColor;
	uniform vec3 uEmitColor;
	uniform vec3 uPlayerLightColor;
	uniform vec4 uFogColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	varying vec4 transformedCoord;
	
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		if (posCosDiff>0.0){
			discard;
		}
	
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.1 + 5.0*dot(adjustedPos,adjustedPos);	//1st num some const to ensure light doesn't go inf at short dist
		
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		float portalLight = dot( uReflectorPos, transformedNormal);
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
		
		
		//ensure isn't something wierd! should be between -1, 1
		//if (portalLight>0.95){portalLight=-0.9;}
		//if (portalLight<-0.95){portalLight=0.9;}
		//portalLight=0.0;
				
		//guess maybe similar to some gaussian light source
		
		vec4 preGammaFragColor = vec4( fog*(( uPlayerLightColor*light+ uReflectorDiffColor*portalLight + uFogColor.xyz )*uColor.xyz + uEmitColor), 1.0) + (1.0-fog)*uFogColor;
		
		//tone mapping
		preGammaFragColor = preGammaFragColor/(1.+preGammaFragColor);	
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		//gl_FragColor = vec4( pow(preGammaFragColor.r,0.455), pow(preGammaFragColor.g,0.455), pow(preGammaFragColor.b,0.455), pow(preGammaFragColor.a,0.455));
		
		gl_FragColor.a =uColor.a;	//TODO confirm check logic for transparent objects
	}
</script>
<script id="shader-perpixel-discard-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uModelScale;
	varying float fog;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	varying vec4 transformedCoord;
	
	void main(void) {	
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		gl_Position = uPMatrix * transformedCoord;
		
#ifdef ATMOS_CONSTANT		
		fog = 0.5*(1.0 + transformedCoord.w);
#else		
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		float total=0.0;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
	}
</script>

<script id="shader-perpixel-transparent-discard-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform vec3 uEmitColor;

	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;	//note currently assume fog distance same for all colours
	varying vec4 transformedCoord;
	varying vec4 transformedNormal;
	
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
		if (posCosDiff>0.0){
			discard;
		}
		
		//some hack for falloff by ~normal dot camera direction to make edges of spherical explosions fade out
		//float light = dot( normalize(transformedCoord).xyz, transformedNormal.xyz);
		//float light = transformedNormal.z;	//this very approx.
		//todo actually dot with direction to camera, divide by sqrt(1-wsq) ? (guess currently get excessive depth falloff)
											//probably should just combo with "fog" value calculation in vert shader
		
		//gl_FragColor = vec4(uEmitColor, fog*light);
		gl_FragColor = vec4(uEmitColor, fog);
	}
</script>
<script id="shader-perpixel-transparent-discard-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec3 uModelScale;
	varying float fog;
	varying vec4 transformedCoord;
	varying vec4 transformedNormal;
	
	void main(void) {	
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		gl_Position = uPMatrix * transformedCoord;
		
		fog = 0.5*(1.0 + transformedCoord.w);
	}
</script>



<script id="shader-texmap-perpixel-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	
	void main(void) {
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.1 + 5.0*dot(adjustedPos,adjustedPos);
		
		gl_FragColor = vec4( fog*( vec3(light) + uFogColor.xyz ), 1.0)*uColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
	}
</script>

<script id="shader-texmap-perpixel-discard-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	uniform vec3 uPlayerLightColor;
	varying float fog;
	uniform vec4 uFogColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;	
		
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		if (posCosDiff>0.0){
			discard;
		}
	
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.1 + 5.0*dot(adjustedPos,adjustedPos);

		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		//guess maybe similar to some gaussian light source
		vec4 preGammaFragColor = vec4( fog*( uPlayerLightColor*light + uReflectorDiffColor*portalLight + uFogColor.xyz ), 1.0)*uColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		
		//tone mapping
		preGammaFragColor = preGammaFragColor/(1.+preGammaFragColor);	

		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		//gl_FragColor = vec4( pow(preGammaFragColor.r,0.455), pow(preGammaFragColor.g,0.455), pow(preGammaFragColor.b,0.455), pow(preGammaFragColor.a,0.455));
	
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
	}
</script>


<script id="shader-texmap-perpixel-discard-normalmap-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	uniform vec3 uPlayerLightColor;
	varying float fog;
	uniform vec4 uFogColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;
	varying vec4 transformedTangent;
	varying vec4 transformedBinormal;
		
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		if (posCosDiff>0.0){
			discard;
		}
		
		vec3 texSample = texture2DProj(uSampler, vTextureCoord).xyz;
				
		vec3 texSampleAdjusted = texSample*vec3(2.)-vec3(1.);
		texSampleAdjusted.xy*=0.4;	//make surface flatter.
				
		texSampleAdjusted = normalize(texSampleAdjusted);
		
		vec4 nmapNormal = transformedNormal*texSampleAdjusted.z +transformedTangent*texSampleAdjusted.x+ transformedBinormal*texSampleAdjusted.y;	//TODO use matrix for normal, tangent, binormal!
	
		vec4 adjustedColor = pow(uColor, vec4(2.-texSampleAdjusted.z));	//bodge - idea is to make colour deeper in recesses. (TODO special bake for this)
	
		float light = -dot( normalize(adjustedPos), nmapNormal);
		
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		
		
		//falloff
		light/=0.1 + 5.0*dot(adjustedPos,adjustedPos);
		
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, nmapNormal);
	
		
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		//guess maybe similar to some gaussian light source
		vec4 preGammaFragColor = vec4( fog*( uPlayerLightColor*light + uReflectorDiffColor*portalLight + uFogColor.xyz ), 1.0)*adjustedColor + (1.0-fog)*uFogColor;

		//tone mapping
		preGammaFragColor = preGammaFragColor/(1.+preGammaFragColor);		
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));

		gl_FragColor.a =1.0;
	}
</script>


<script id="shader-texmap-perpixel-discard-normalmap-efficient-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	uniform vec3 uPlayerLightColor;
	varying float fog;
	uniform vec4 uFogColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	uniform float uSpecularStrength;
	uniform float uSpecularPower;

	varying vec4 vPlayerLightPosTangentSpace;
	varying vec4 vPortalLightPosTangentSpace;
	varying vec4 vEyePosTangentSpace;
	
	varying vec4 transformedCoord;

	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;	//TODO is transformedcoord still needed if have vPortalLightPosTangentSpace ? 
	
		if (posCosDiff>0.0){
			discard;
		}
		
		vec3 texSample = texture2DProj(uSampler, vTextureCoord).xyz;
				
		vec3 texSampleAdjusted = texSample*vec3(2.)-vec3(1.);
		texSampleAdjusted.xy*=0.4;	//make surface flatter.
				
		texSampleAdjusted = normalize(texSampleAdjusted);
		
		vec4 nmapNormal = vec4(texSampleAdjusted,0.0);	//trivial TODO tidy up
		

		vec4 adjustedColor = pow(uColor, vec4(2.-texSampleAdjusted.z));	//bodge - idea is to make colour deeper in recesses. (TODO special bake for this)
	
		
		vec4 normalizedLightPos = normalize(vPlayerLightPosTangentSpace);
		vec4 normalizedLightPosAdj = normalize(vec4( vPlayerLightPosTangentSpace.xyz , 0.0));
		
		float light = dot( normalizedLightPosAdj, nmapNormal);		
		
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		
#ifdef SPECULAR_ACTIVE		
		//add specular component (currently for playerLight only)
		//really should also take into account that light is not point source, especially relevant if apply logic to portal light too, but 
		//	guess if surface not that shiny will work OK with assumption
		//TODO something more efficient. can the halfVec be a varying? what should it be (tried normalising it in vert shader and doesnt interpolate well)
		
		vec4 normalizedEyePosAdj = normalize(vec4( vEyePosTangentSpace.xyz , 0.));	
		
		//float phongAmount = pow(max(dot(normalizedEyePosAdj, nmapNormal),0.),10.);	//simple glossy camera light
		vec4 halfVec = normalize(normalizedEyePosAdj + normalizedLightPosAdj);
		float phongAmount = uSpecularStrength*pow( max(dot(halfVec, nmapNormal), 0.),uSpecularPower);
		
		light+=phongAmount;
#endif		
		//falloff
	//	light/=0.1 + 5.0*(1.0-normalizedLightPos.w);				//results consistent with "inefficient" version for small distances
		vec4 vecToLight = normalizedLightPos - vec4(vec3(0.0),1.0);	//result fully consistent with "inefficient" version, but maybe not worth extra calcs
		light/=0.1 + 5.0*dot(vecToLight,vecToLight);
		
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( vPortalLightPosTangentSpace, nmapNormal);
						
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos


		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		//guess maybe similar to some gaussian light source
		vec4 preGammaFragColor = vec4( fog*( uPlayerLightColor*light + uReflectorDiffColor*portalLight + uFogColor.xyz ), 1.0)*adjustedColor + (1.0-fog)*uFogColor;

		//tone mapping
		preGammaFragColor = preGammaFragColor/(1.+preGammaFragColor);		
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
	
		gl_FragColor.a =1.0;
	}
</script>


<script id="shader-texmap-perpixel-gradlight-discard-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	uniform vec3 uPlayerLightColor;
	uniform float thrustAmount;
	varying float fog;
	uniform vec4 uFogColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;	
	
	uniform vec3 uLightPosPlayerFrame;	//tmp. TODO do this stuff in v shader
	
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		if (posCosDiff>0.0){
			discard;
		}
	
	/*
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.7 + 3.0*dot(adjustedPos,adjustedPos);
	*/
		//tmp remove player light 
	
	/*
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);										
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
		*/
		//todo figure out the above and make lighting in this shader consistent with lighting of other objects
		
		//bodge - treat as if gradient light, where centre colour = uFogColor + 0.5*(uReflectorDiffColor*portalLight), gradient = uReflectorDiffColor*portalLight
		//TODO maybe better to approximate light as some percentage standard directional light, some amount gradient (all gradient at portal surface)
		//maybe quadratic gradient light will be significant improvement (but may require many textures)
		float gradRange = 1.0 / (1.0 + 3.0*dot(posCosDiff,posCosDiff));
		vec3 averageLight = uFogColor.xyz + uReflectorDiffColor * 0.5*gradRange;
			//calculation contribution of gradient lights and sum. this is portalLight vector basically.
		
		//vec3 modifiedLightDirection = vec3(0.5,-0.5,0.0);	//TODO use correct
		vec3 modifiedLightDirection = gradRange*normalize(uLightPosPlayerFrame.xyz);	//TODO scale less when far from portal surf (by difference betwee "average" colour and fog) 
		vec3 modifiedLightDirectionR = modifiedLightDirection*uReflectorDiffColor.r;	//todo matrix notation, do in vert shader
		vec3 modifiedLightDirectionG = modifiedLightDirection*uReflectorDiffColor.g;
		vec3 modifiedLightDirectionB = modifiedLightDirection*uReflectorDiffColor.b;
		
		vec4 vChanWeightsR = vec4(modifiedLightDirectionR, averageLight.r-dot(modifiedLightDirectionR,vec3(0.5)));
		vec4 vChanWeightsG = vec4(modifiedLightDirectionG, averageLight.g-dot(modifiedLightDirectionG,vec3(0.5)));
		vec4 vChanWeightsB = vec4(modifiedLightDirectionB, averageLight.b-dot(modifiedLightDirectionB,vec3(0.5)));
		
		float uMaxAlbedo = 0.4;	//todo use uColor? (baked maps assume some albedo though)
		vChanWeightsR*=uMaxAlbedo;
		vChanWeightsG*=uMaxAlbedo;
		vChanWeightsB*=uMaxAlbedo;	//todo just apply after litColor
		
		vec4 sampleColor = texture2DProj(uSampler, vTextureCoord);
		
		vec3 litColor = vec3( dot(sampleColor, vChanWeightsR), 
								dot(sampleColor, vChanWeightsG),
								dot(sampleColor, vChanWeightsB));
		
		//litColor = vec3(0.0);	//zero lighting to test below stuff
		
		//bodge thruster light by player space light contributon. this is very approximate!
		//todo replace by baked thruster light
		//litColor.b += sampleColor.a;	//isotropic light contribution
		//litColor.b += sampleColor.r;	//light contribution from the left
		//litColor.b += sampleColor.g;	//light contribution from behind
		//litColor.b += sampleColor.b;	//light contribution from below
		vec3 thrustLightColor = vec3(0.1,0.2,0.9)* thrustAmount;
		litColor += thrustLightColor*max(sampleColor.g-0.5,0.0);	//bodge - lighting is half for normals perpendicular to fwd/back, but gets intended effect of light from behind
		
		//guess maybe similar to some gaussian light source
		//vec4 preGammaFragColor = vec4( fog*( uPlayerLightColor*light + uReflectorDiffColor*portalLight + uFogColor.xyz ), 1.0)*uColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		vec4 preGammaFragColor = vec4( fog*litColor, 1.0) + (1.0-fog)*uFogColor;

		//tone mapping
		preGammaFragColor = preGammaFragColor/(1.+preGammaFragColor);	
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		//gl_FragColor = vec4( pow(preGammaFragColor.r,0.455), pow(preGammaFragColor.g,0.455), pow(preGammaFragColor.b,0.455), pow(preGammaFragColor.a,0.455));
	
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
	}
</script>

<!-- vertex shader with tex coords -->
<script id="shader-texmap-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying float fog;
	uniform vec3 uModelScale;
	varying vec3 veclight;
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		
		gl_Position = uPMatrix * transformedCoord;

		vec4 transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.1 + 5.0*dot(adjustedPos,adjustedPos);	//1st num some const to ensure light doesn't go inf at short dist
													//guess maybe similar to some gaussian light source
		
		veclight=vec3(light);
		
		fog = 0.5*(1.0 + transformedCoord.w);
		
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>


<!-- vertex shader with tex coords, per pixel -->
<script id="shader-texmap-perpixel-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying float fog;
	uniform vec3 uModelScale;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		
		fog = 0.5*(1.0 + transformedCoord.w);

		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>

<script id="shader-texmap-perpixel-discard-normalmap-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	attribute vec3 aVertexTangent;
	attribute vec3 aVertexBinormal;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying float fog;
	uniform vec3 uModelScale;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	varying vec4 transformedCoord;
	varying vec4 transformedTangent;
	varying vec4 transformedBinormal;
	
	void main(void) {
		vec3 scaledPos = uModelScale*aVertexPosition;
		vec4 aVertexPositionNormalized = normalize(vec4(scaledPos, 1.0));
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		
		gl_Position = uPMatrix * transformedCoord;

		vec4 untransformedNormal = normalize( vec4( aVertexNormal, -dot(aVertexNormal, scaledPos)));	
		vec4 untransformedTangent = normalize( vec4( aVertexTangent, -dot(aVertexTangent, scaledPos)));	
		vec4 untransformedBinormal = normalize( vec4( aVertexBinormal, -dot(aVertexBinormal, scaledPos)));	
		
		transformedNormal = uMVMatrix * untransformedNormal;
		transformedTangent = uMVMatrix * untransformedTangent;	
		transformedBinormal = uMVMatrix * untransformedBinormal; 
		
		/*
		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);	//TODO use matrix for normal, tangent, binormal
		transformedTangent = uMVMatrix * vec4(aVertexTangent,0.0);
		transformedBinormal = uMVMatrix * vec4(aVertexBinormal,0.0);
			//these should be approximately right for small objects.
			//however, really should be something like  normalise( vec4(aVertexPosition + delta*aVertexNormal, 1.0) - aVertexPositionNormalized ) 
			//is there is a neat calculation? are the results any different?
		*/
		adjustedPos = transformedCoord - uDropLightPos;
		
		fog = 0.5*(1.0 + transformedCoord.w);
		
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>


<script id="shader-texmap-perpixel-discard-normalmap-efficient-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	attribute vec3 aVertexTangent;
	attribute vec3 aVertexBinormal;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying float fog;
	uniform vec3 uModelScale;
	uniform vec4 uReflectorPosVShaderCopy;	//TODO not this! shouldn't need in both. unsure why need different name. limitation of webgl, or bad assumption in shader loading func?
	
	varying vec4 vPlayerLightPosTangentSpace;
	varying vec4 vPortalLightPosTangentSpace;
	varying vec4 vEyePosTangentSpace;			//does this get skipped automatically if not used?
	
	varying vec4 transformedCoord;
	
	void main(void) {
		vec3 scaledPos = uModelScale*aVertexPosition;
		vec4 aVertexPositionNormalized = normalize(vec4(scaledPos, 1.0));
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		
		gl_Position = uPMatrix * transformedCoord;

		//transform by normal/tangent/bitangent. TODO use matrix formulation. 3x3 or 4x4? (adjustedPos is a 4vector. ??)
		//this is "efficient" version that moves some work from frag to vertex shader.
		//note could transform the position of lighting objects instead of transforming pos,normal,binormal,tangent, which might be still more efficient.
		//currently not equvalent results - this seems too dim where light very close to object surface.
		
		vec4 untransformedNormal = normalize( vec4( aVertexNormal, -dot(aVertexNormal, scaledPos)));	
		vec4 untransformedTangent = normalize( vec4( aVertexTangent, -dot(aVertexTangent, scaledPos)));	
		vec4 untransformedBinormal = normalize( vec4( aVertexBinormal, -dot(aVertexBinormal, scaledPos)));	
		
		vec4 transformedNormal = uMVMatrix * untransformedNormal;
		vec4 transformedTangent = uMVMatrix * untransformedTangent;	
		vec4 transformedBinormal = uMVMatrix * untransformedBinormal; 
				
		vPlayerLightPosTangentSpace.x = dot(transformedTangent, uDropLightPos);
		vPlayerLightPosTangentSpace.y = dot(transformedBinormal, uDropLightPos);
		vPlayerLightPosTangentSpace.z = dot(transformedNormal, uDropLightPos);
		vPlayerLightPosTangentSpace.w = dot(transformedCoord, uDropLightPos);
		
		vPortalLightPosTangentSpace.x = dot(transformedTangent, uReflectorPosVShaderCopy);
		vPortalLightPosTangentSpace.y = dot(transformedBinormal, uReflectorPosVShaderCopy);
		vPortalLightPosTangentSpace.z = dot(transformedNormal, uReflectorPosVShaderCopy);
		vPortalLightPosTangentSpace.w = dot(transformedCoord, uReflectorPosVShaderCopy);

#ifdef SPECULAR_ACTIVE		
		vec4 eyePos = vec4(vec3(0.),1.);
		vEyePosTangentSpace.x = dot(transformedTangent, eyePos);
		vEyePosTangentSpace.y = dot(transformedBinormal, eyePos);
		vEyePosTangentSpace.z = dot(transformedNormal, eyePos);
		vEyePosTangentSpace.w = dot(transformedCoord, eyePos);
		
		//https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_reflection_model
		//camPosTangentSpace should be normalised already (?? maybe depends on transform+TBN matrix being SO(4)? - but currently just using 3vecs (TODO is this best method?)
		//vPlayerLightHalfwayTangentSpace = vec4(normalize(normalize(vEyePosTangentSpace.xyz) + normalize(vPortalLightPosTangentSpace.xyz)), 0.) ;	//TODO should normalisation take place after interpolation? 	//seems interpolation doesn't work well for this. maybe some trick can do. for now do normalisation in frag shader
#endif	
		fog = 0.5*(1.0 + transformedCoord.w);
		
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>

<!-- vertex shader with tex coords, per pixel -->
<script id="shader-texmap-perpixel-discard-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying float fog;
	uniform vec3 uModelScale;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		gl_Position = uPMatrix * transformedCoord;

#ifdef ATMOS_CONSTANT		
		fog = 0.5*(1.0 + transformedCoord.w);
#else		
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		float total=0.0;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
		
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>

<script id="shader-texmap-perpixel-discard-vertvel-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	attribute vec3 aVertexVelocity;
	varying vec3 vTextureCoord;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform float uVertexMove;
	varying float fog;
	uniform vec3 uModelScale;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;
	
	void main(void) {
		vec3 shiftedPosition = uModelScale*aVertexPosition + aVertexVelocity*uVertexMove;
		vec4 aVertexPositionNormalized = normalize(vec4(shiftedPosition, 1.0));
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		gl_Position = uPMatrix * transformedCoord;

#ifdef ATMOS_CONSTANT		
		fog = 0.5*(1.0 + transformedCoord.w);
#else		
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		float total=0.0;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
		
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>

<!-- vertex shader with tex coords and 4vector input positions (instead of projected 3vectors.)-->
<script id="shader-texmap-vs-4vec" type="x-shader/x-vertex">
	attribute vec4 aVertexPosition;
	attribute vec4 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec4 uCameraWorldPos;
	uniform vec3 uPlayerLightColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec3 veclight;
	
	void main(void) {
		vec4 transformedCoord = uMVMatrix * aVertexPosition;
		gl_Position = uPMatrix * transformedCoord;
#ifdef ATMOS_CONSTANT		
		fog = 0.5*(1.0 + transformedCoord.w);
#else
		vec4 worldCoord = uMMatrix * aVertexPosition;
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		float total=0.0;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
		vec4 transformedNormal = uMVMatrix * aVertexNormal;
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		light/=1.0 + 4.2*dot(adjustedPos,adjustedPos);		//terms higher than other shaders by sqrt(2) because length
															//of 1,0,0,0 -> 0,1,0,0 (90 deg around world)
															//TODO recalc this since have changed falloff calc in other shaders
		//TODO can process multiple lights using matrix?
		
		veclight=uPlayerLightColor*light;
		
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		veclight+=uReflectorDiffColor*portalLight;
				
		vTextureCoord = vec3( aTextureCoord.st, 1.0 );
	}
</script>


<!-- vertex shader with tex coords and 4vector input positions (instead of projected 3vectors.)-->
<script id="shader-texmap-perpixel-normalmap-vs-4vec" type="x-shader/x-vertex">
	attribute vec4 aVertexPosition;
	attribute vec4 aVertexNormal;
	attribute vec4 aVertexTangent;
	attribute vec4 aVertexBinormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	
	uniform vec4 uReflectorPosVShaderCopy;
	varying float fog;
	
	varying vec4 vPlayerLightPosTangentSpace;
	varying vec4 vPortalLightPosTangentSpace;
	varying vec4 vEyePosTangentSpace;
	
	varying vec4 transformedCoord;	
	
	void main(void) {
		transformedCoord = uMVMatrix * aVertexPosition;
		gl_Position = uPMatrix * transformedCoord;
		
		vec4 transformedNormal = uMVMatrix * aVertexNormal;
		vec4 transformedTangent = uMVMatrix * aVertexTangent;	
		vec4 transformedBinormal = uMVMatrix * aVertexBinormal; 
				
		vPlayerLightPosTangentSpace.x = dot(transformedTangent, uDropLightPos);
		vPlayerLightPosTangentSpace.y = dot(transformedBinormal, uDropLightPos);
		vPlayerLightPosTangentSpace.z = dot(transformedNormal, uDropLightPos);
		vPlayerLightPosTangentSpace.w = dot(transformedCoord, uDropLightPos);
		
		vPortalLightPosTangentSpace.x = dot(transformedTangent, uReflectorPosVShaderCopy);
		vPortalLightPosTangentSpace.y = dot(transformedBinormal, uReflectorPosVShaderCopy);
		vPortalLightPosTangentSpace.z = dot(transformedNormal, uReflectorPosVShaderCopy);
		vPortalLightPosTangentSpace.w = dot(transformedCoord, uReflectorPosVShaderCopy);
#ifdef SPECULAR_ACTIVE		
		vec4 eyePos = vec4(vec3(0.),1.);
		vEyePosTangentSpace.x = dot(transformedTangent, eyePos);
		vEyePosTangentSpace.y = dot(transformedBinormal, eyePos);
		vEyePosTangentSpace.z = dot(transformedNormal, eyePos);
		vEyePosTangentSpace.w = dot(transformedCoord, eyePos);
#endif		
		fog = 0.5*(1.0 + transformedCoord.w);
		
		vTextureCoord = vec3( aTextureCoord.st, 1.0 );		//todo pass in unnormalised, use z tex coord for length (and normalise before passing onto frag shader)
	}
</script>


<script id="shader-texmap-color-triplanar-vs-4vec-atmos" type="x-shader/x-vertex">
	//TODO determine whether more efficient to calc aVertexPosition, aVertexNormal from aTriCoord, aTriNormal here in vert shader, or precalc and pass in.
	#define CONST_ITERS 64.0

	attribute vec4 aVertexPosition;
	attribute vec4 aVertexNormal;
	attribute vec3 aVertexColor;
	attribute vec3 aTriCoord;
	attribute vec3 aTriNormal;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uPlayerLightColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec3 veclight;
	varying vec3 vPos;		//3vector position (before mapping onto duocyinder)
	varying vec3 vTexAmounts;
	
	void main(void) {
		vec4 transformedCoord = uMVMatrix * aVertexPosition;
		vec4 worldCoord = uMMatrix * aVertexPosition;
		gl_Position = uPMatrix * transformedCoord;
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd);
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float total=0.0;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
		
		
		
		vec4 transformedNormal = uMVMatrix * aVertexNormal;
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		light/=1.0 + 4.2*dot(adjustedPos,adjustedPos);		//terms higher than other shaders by sqrt(2) because length
															//of 1,0,0,0 -> 0,1,0,0 (90 deg around world)
															//todo recalc
		//TODO can process multiple lights using matrix?
		
		veclight=uPlayerLightColor*light;
		
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		veclight+=uReflectorDiffColor*portalLight;
		veclight*=aVertexColor;
		//veclight=aVertexColor;
				
		//vTexAmounts = vec3(1.0);	//aTriNormal*aTriNormal;
		vPos = aTriCoord;
		vTexAmounts = aTriNormal*aTriNormal;
	}
</script>


<!-- vertex shader with tex coords and 4vector input positions (instead of projected 3vectors.)-->
<script id="shader-texmap-vs-4vec-mapproject" type="x-shader/x-vertex">
	attribute vec4 aVertexPosition;
	attribute vec4 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uPlayerLightColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec3 veclight;
	varying vec4 vVertexPos;
	
	void main(void) {
		vVertexPos = aVertexPosition;	//pass through for atan tex mapping (overriding uv)
	
		vec4 transformedCoord = uMVMatrix * aVertexPosition;
		gl_Position = uPMatrix * transformedCoord;
				
#ifdef ATMOS_CONSTANT
		fog = 0.5*(1.0 + transformedCoord.w);
#else
		vec4 worldCoord = uMMatrix * aVertexPosition;
		float dotProd = dot(uCameraWorldPos,worldCoord);
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif	
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		float total=0.0;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);	
#endif
		//vec4 transformedNormal = uMVMatrix * aVertexNormal;	//normals code is buggy
		vec4 transformedNormal = uMVMatrix * aVertexNormal;	
		
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		
		float light = -dot( normalize(adjustedPos), transformedNormal);
		//float light = 1.0;
		
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		light/=1.0 + 4.2*dot(adjustedPos,adjustedPos);		//terms higher than other shaders by sqrt(2) because length
															//of 1,0,0,0 -> 0,1,0,0 (90 deg around world)
															//todo recalc
		veclight=uPlayerLightColor*light;
		
		
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		
		
		float portalLight = dot( uReflectorPos, transformedNormal);
		
		//float portalLight = dot( normalize(uReflectorPos - transformedCoord) , transformedNormal);	//does this make more sense?
		//float portalLight = dot( uReflectorPos - transformedCoord , transformedNormal);
		
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		veclight+=uReflectorDiffColor*portalLight;
				
		vTextureCoord = vec3( aTextureCoord.st, 1.0 );
	}
</script>

<!-- vertex shader for water. take 2vec position, calc height, wrap around duocylinder (3vec to 4vec)-->
<script id="shader-texmap-vs-duocylinder-sea" type="x-shader/x-vertex">
	#define CONST_TAU 6.2831853
	
	attribute vec2 aVertexPosition;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform float uTime;
	uniform float uZeroLevel;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uPlayerLightColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec3 veclight;
	
	varying vec3 vTextureCoord;
	
	void addWaveContribution(in vec2 wavePosIn, inout vec3 wavePosAccum, inout vec3 vDerivativeWRTX, inout vec3 vDerivativeWRTY, float peakiness, vec2 waveCycles){	//waveCycles should be int2
		//wavecycles - number of waves across repeating square in each direction.
		//wavevector relates to this...
		//speed of wave - deep water, speed ~ sqrt(wavelength)
		// wavevector = 2pi/wavelength. wave speed= angularvelocity*wavevector ie (rads/s) / (rads/m)
			//		or speed = frequency*wavelength
			
		// sqrt(wavelength) = angvec * (2pi/wavelength)
		
		//frequency = speed/wavelength ~ sqrt(wavelength)/wavelength = 1/sqrt(wavelength)
		
		//square is 16x16 (TODO make unit square? then can change grid size for fidelity without other messing
		
		//var normalisedGridPos = wavePos
				
		//wavevector is wavecycles * 2PI / square_side_length
		// square_side_length = 1
		
		//wavevector (IIRC direction/wavelength) ~ vec2(n,m), so wavelength = 1/sqrt(n*n+m*m)
		// wavelength = 1/length (wavevector/2PI) = 1/length(wavecycles)
		
		float invWavelength = length(waveCycles);
		
		//since freq and therefore ang vel proportional to 1/invWavelength
		float someConstant = 0.4;	//affects speed of animation
		float freq = someConstant*sqrt(invWavelength);	//<--this why pythagorean tribles not working!
			//unless find triples whose lengths are square! eg 7 24 25, (and 0 1 1, 0 4 4 0 9 9 etc)
		//presumably there is some distribution of wave amplitude with wavelength. for now just try manual terms. IIRC some ratio (since fluid particles circular path)
		//makes pointy waves. therefore pass in "peakiness" - 1 for sharp peak. rolling wheel. 1 revolution in 2pi radii -> pi* peak-to-peak amplitude
		
		//round angfreq so loops? (uTime from 0 to 1 so freq should be integer)
		freq=ceil(freq);
		
		/*
		float phase = CONST_TAU * (uTime*angFreq + dot(waveCycles, wavePosIn.xy));	//TODO should angvel be hardcoded/passed into shader (rather than calc for each vertex)
									//if time is to loop, should ensure waves loop in time - guess by subtle manipulation of angVel (pythagorean triples unrealistic)
		//is this the problem?
		phase=mod(phase,CONST_TAU);	//if works, should mod with 1 before multiplying with CONST_TAU. .... it doesn't work! still glitches!	
		*/
		
		float phase = CONST_TAU* (uTime*freq + dot(waveCycles, wavePosIn));	
		
		float ampl = peakiness/(invWavelength*CONST_TAU);
		wavePosAccum+= ampl*vec3( cos(phase)*waveCycles/invWavelength, sin(phase) );
		
		//add derivative to vDerivativeWRTX, vDerivativeWRTY (TODO combine into matrix?)
		vec3 derivVector = ampl*vec3( -sin(phase)*waveCycles/invWavelength , cos(phase) );	//educated guess TODO proper working
		vDerivativeWRTX += waveCycles.x * derivVector;
		vDerivativeWRTY += waveCycles.y * derivVector;
	}
	
	//ported from tennisBallLoader.js
	vec4 get4vecfrom3vec(in vec3 invec){
		vec2 ang = CONST_TAU * invec.xy;
		float cylr = CONST_TAU * (0.125+ invec.z);
		float sr = sin(cylr);	//todo possible to do this in 1 go? special shader cmmd?
		float cr = cos(cylr);
		return vec4( cr * sin(ang.x), cr * cos(ang.x), sr * sin(ang.y), sr * cos(ang.y) );
	}
	
	void main(void) {
		//1 calc height and normal
		vec3 vDerivativeWRTX = vec3(1./CONST_TAU,0.,0.);
		vec3 vDerivativeWRTY = vec3(0.,1./CONST_TAU,0.);
		
		vec3 vModifiedVertexPosition = vec3( aVertexPosition.xy, uZeroLevel);
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(1.0,9.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(-13.0,2.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(3.0,-7.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(-4.0,5.0));
		
		vec3 surfNorm = normalize(cross(vDerivativeWRTX,vDerivativeWRTY));	//get surface normal by cross product of derivative vectors
				
		//2 convert position and normal to 4vec
		//fake initially to get right vec type
		//vec4 calculatedVertexPosition = vec4(aVertexPosition, 0.,0.);
		vec4 calculatedVertexPosition = get4vecfrom3vec(vModifiedVertexPosition);
		
		//simple way to calc norms - move a little along normal, subtract this from original value, normalise the result.
		//probably can express as a derivative wrt normal movment, then normalise result, but this way is easier.
		vec4 shiftedVertexPosition = get4vecfrom3vec(vModifiedVertexPosition+.001*surfNorm);
		vec4 calculatedVertexNormal = normalize(shiftedVertexPosition - calculatedVertexPosition);
		
		//3 use thse values same as in shader-texmap-vs-4vec
		vec4 transformedCoord = uMVMatrix * calculatedVertexPosition;
		
		gl_Position = uPMatrix * transformedCoord;
		
#ifdef ATMOS_CONSTANT
		fog = 0.5*(1.0 + transformedCoord.w);
#else
		vec4 worldCoord = uMMatrix * calculatedVertexPosition;
		/*
		float dotProd = dot(uCameraWorldPos,worldCoord);
		float maxAng = acos(dotProd);	//angle from camera to object
		float maxAngOverIters = maxAng/CONST_ITERS;
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		float totalPath=0.0;
		float currentAngle;
		vec4 currentPos;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			currentAngle=maxAngOverIters*aa;
			currentPos = uCameraWorldPos*cos(currentAngle)+normalDirection*sin(currentAngle);
			totalPath+=exp(uAtmosContrast*dot(currentPos.xy,currentPos.xy));	//number here affects how different atmos pressure is between extremes
		}
		fog=exp(-totalPath*uAtmosThickness*maxAngOverIters);
		*/
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif		
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		float total=0.0;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
	
		vec4 transformedNormal = uMVMatrix * calculatedVertexNormal;
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		light/=1.0 + 4.2*dot(adjustedPos,adjustedPos);		//terms higher than other shaders by sqrt(2) because length
															//of 1,0,0,0 -> 0,1,0,0 (90 deg around world)
															//todo recalc
		veclight=uPlayerLightColor*light;
		
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		veclight+=uReflectorDiffColor*portalLight;
		
		vTextureCoord = vec3( aVertexPosition, 1.0 );	//any point in projected tex??
	}
</script>

<!-- simple cubemap pix shader -->
<script id="shader-cubemap-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform samplerCube uSampler;
	varying vec3 vPos;
	varying float fog;
	uniform vec4 uColor;	//TODO remove? (should be white, but useful to tint for debug/ coloured reflector)
	uniform vec4 uFogColor;
	
	void main(void) {
		//gl_FragColor = uColor*textureCube(uSampler, vPos);	//TODO use this (get rid of fog)
		
		vec3 preGammaFragColor = pow(textureCube(uSampler, vPos).xyz,vec3(2.2));
		
		//undo tone mapping . y=1/(1+x) => x=y/(1-y)
		//seems like in practice, undoing, redoing tone mapping has little value, but guess because currently not using very bright lighting.
		//TODO check whether still need this - 
		
		vec3 preToneMap = preGammaFragColor / (1.001 - preGammaFragColor);	//using 1.001 instead of 1 to prevent /0 problems
		preToneMap = vec3(fog)*uColor.xyz*preToneMap + (1.0-fog)*uFogColor.xyz;
		
		//reapply tone mapping
		preGammaFragColor = preToneMap/(1.+preToneMap);
		
		gl_FragColor = vec4( pow(preGammaFragColor, vec3(0.455)) , 1.0);
	}
</script>
<!-- vertex shader -->
<script id="shader-cubemap-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	varying vec3 vPos;
	varying float fog;	//TODO remove (fog should be applied at cubemap generation (unless fog is exponential decay)
	uniform vec3 uModelScale;
	uniform mat4 uPosShiftMat;
	uniform float uPolarity;

	uniform float uAtmosThickness;
	uniform float uAtmosContrast;	//atmos variants specific
	uniform mat4 uMMatrix;
	uniform vec4 uCameraWorldPos;

	uniform vec3 uCentrePosScaled;	//vertproj specific. this is position of cubemap centre point in unprojected model space

	void main(void) {
#ifdef VERTPROJ
		float csq = dot(uCentrePosScaled,uCentrePosScaled);
		float cdotp = dot(uCentrePosScaled, -aVertexPosition);
		float a = pow((1.0-csq)+cdotp*cdotp, 0.5) - cdotp;
		vec3 scaledVertexPosition = aVertexPosition*a;
	
		vec4 aVertexPositionNormalized = normalize(vec4( uModelScale*(scaledVertexPosition-uCentrePosScaled), 1.0));	
#else
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));	//project 3d object onto 3sphere
																//can avoid this by inputting 4vector positions *...
#endif
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;

#ifdef ATMOS_CONSTANT
		fog = 0.5*(1.0 + transformedCoord.w);
#else
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;
#endif
#ifdef ATMOS_ONE
		//calculcate position on surface of portal if camera is inside portal. 
		//todo can this be calculated more efficiently along with other terms?
		//float fudgeSizeVal = 0.953; 	//above this w component inside portal. expect this for portal scale =0.3 because root(1-0.3*0.3). 
										//todo pass through portal size
		float fudgeSizeVal = 0.96; 	//works better, guess because problems with approximation
		vec4 rayStart = uCameraWorldPos;
		if (uCameraWorldPos.w > fudgeSizeVal){	//can lose if here if separate shader for within/out portal
			//dumb approximation, should work for small distances - just find where line from start to end intersects plane for w=fudgeSizeVal
			vec4 midpoint = vec4( ((uCameraWorldPos.w - fudgeSizeVal)*worldCoord.xyz + (fudgeSizeVal - worldCoord.w)*uCameraWorldPos.xyz)/(uCameraWorldPos.w-worldCoord.w) , fudgeSizeVal);
			rayStart = normalize(midpoint);	
		}
		
		/*
		fog = 0.5*(1.0 + transformedCoord.w);
		//note 1.0 = no fog, 0 = total fog.
		//more complex fog calculation. show that can have radial dependence. not anything like physically correct!
		float airDensityAtObj = exp(-dot(worldCoord.xy,worldCoord.xy));
		fog*=airDensityAtObj; 
		*/
		
		//although this is used for "per pixel" version, currently calculating fog per vertex.
		
		/*
		float dotProd = dot(uCameraWorldPos,worldCoord);
		float maxAng = acos(dotProd*0.999);	//angle from camera to object
		float maxAngOverIters = maxAng/CONST_ITERS;
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		float totalPath=0.0;
		float currentAngle;
		vec4 currentPos;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			currentAngle=maxAngOverIters*aa;
			currentPos = uCameraWorldPos*cos(currentAngle)+normalDirection*sin(currentAngle);
			totalPath+=exp(uAtmosContrast*dot(currentPos.xy,currentPos.xy));	//number here affects how different atmos pressure is between extremes
		}
		fog=exp(-totalPath*uAtmosThickness*maxAngOverIters);
		*/
	
		float dotProd = dot(rayStart,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*rayStart);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(rayStart.xy, rayStart.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(rayStart.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd*0.999);
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float total=0.0;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);

#endif
#ifdef ATMOS_TWO
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd*0.999);
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
	
		//gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); // *... or can just use 1.0 without normalising? TODO try.
		gl_Position = uPMatrix * transformedCoord;
		vPos = uPolarity * (uPosShiftMat*aVertexPositionNormalized).xyz;
	}
</script>


<script type="text/javascript" src="js/main.js"></script>


</head>

<body onload="init()">
<div id="info">3-sphere visualised in WebGL demo. Arrow keys, QE, click+drag mouse to rotate. WASD, space/ctrl to translate.<a href="https://github.com/filbs111/3sphere-explorer" target="_blank">https://github.com/filbs111/3sphere-explorer</a></div>
<div id="info2" style="display:none">TEST</div>
		
<!--<svg style="position:absolute;background:#0000;left:780px;top:330px" height="200" width="200">
  <circle cx="100" cy="100" r="80" stroke="yellow" stroke-width="2" fill="none" />
  <circle cx="100" cy="100" r="5" stroke="yellow" stroke-width="2" fill="none" />
</svg>-->
<canvas id="mycanvas" width="0" height="0">CANVAS TO GO HERE</canvas>


</body>


</html>