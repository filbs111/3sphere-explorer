<!DOCTYPE html>
<html>

<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<title>3-sphere explorer</title>

<style>
	body {
		margin: 0px;
		overflow: hidden;
	}

	#info, .debuginfo {
		position: absolute;
		padding: 20px;
	}

	.debuginfo {
		text-align: left;
		background: #0007;
		font-family: 'Lucida Console', Monaco, monospace;
		font-weight: bold;
	}

	#info {
		top: 0px; width: 100%;
		color: white;
		text-align: center;
	}
	
	#info2 {
		top: 89%; width: 100%;
		color: red;
	}

	#info3 {
		top: 95%; width: 100%;
		color: greenyellow;
	}
	
	#info a:link {
				color: white;
	}
		
	#info a:visited {
		color: white;
	}
</style>
<script type="text/javascript" src="js/top_stuff.js"></script>
<script type="text/javascript" src="lib/dat.gui.min.js"></script>
<script type="text/javascript" src="lib/stats.min.js"></script>
<script type="text/javascript" src="lib/perlin.js"></script><!-- https://github.com/josephg/noisejs/blob/master/perlin.js -->
<script type="text/javascript" src="lib/gl-matrix-min.js"></script>
<script type="text/javascript" src="utils/heap_perf.js"></script>
<script type="text/javascript" src="utils/matfuncs.js"></script>
<script type="text/javascript" src="utils/perlinfuncs.js"></script>
<script type="text/javascript" src="utils/fullscreen.js"></script>
<script type="text/javascript" src="utils/webgl_utils.js"></script>
<script type="text/javascript" src="utils/shader_loader.js"></script>
<script type="text/javascript" src="utils/keys.js"></script>
<script type="text/javascript" src="utils/gamepad.js"></script>
<script type="text/javascript" src="utils/gamepad_settings.js"></script>
<script type="text/javascript" src="utils/multisound.js"></script>
<script type="text/javascript" src="utils/object_loader.js"></script>
<script type="text/javascript" src="data/sphere.js"></script>
<script type="text/javascript" src="data/quad.js"></script>
<script type="text/javascript" src="data/levelCubeData.js"></script>
<script type="text/javascript" src="data/explodingCubeData.js"></script>
<script type="text/javascript" src="data/tennisBall.js"></script>
<script type="text/javascript" src="data/grid1.obj.json.min"></script>
<script type="text/javascript" src="data/terrain/untitled64tri-deduped-wrap.obj.json.min"></script>
<script type="text/javascript" src="data/gridData.js"></script>
<script type="text/javascript" src="data/proceduralTerrain.js"></script>
<script type="text/javascript" src="data/seaheight.js"></script>
<script type="text/javascript" src="data/duocylinderBoxInfo.js"></script>
<script type="text/javascript" src="data/tennisBallLoader.js"></script>
<script type="text/javascript" src="data/cube-frame-a1-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/cube-frame-a2-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/octohedron-nosubdiv-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/octohedron-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/tetra-frame.obj.json"></script>
<script type="text/javascript" src="data/tetra-frame1-subdiv.obj.json"></script>
<script type="text/javascript" src="data/dodecahedron-frame-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/wt_teapot-trimmed.obj.json"></script>
<script type="text/javascript" src="data/icoball.obj.json"></script>
<script type="text/javascript" src="data/hyperboloidData.js"></script>
<script type="text/javascript" src="data/cells.js"></script>
<script type="text/javascript" src="data/ringCells.js"></script>
<script type="text/javascript" src="data/voxterrain.js"></script>



<!-- version where pushed away from input position for aerodynamic effect -->
<!-- currently subtle/pointless -->
<script id="shader-lensing-billboard-vs" type="x-shader/x-vertex">
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//not used as a light, but position is coincident

	attribute vec4 aVertexCentrePosition;	//instanced attribute
	attribute vec2 aVertexPosition;			//offset position

	//todo make larger and fade with distance to avoid resolution problems (or make larger generally and use mipmapped blob texture)
	//todo tile towards camera or scale so appears correctly in rectilinear projection (sphere off axis should appear as ellipse)

	void main(void) {
		vec4 transformedCoord = uMVMatrix * aVertexCentrePosition;
		
		//various ways can displace, this is fairly simple:
		vec4 differenceVec = transformedCoord - uDropLightPos;
		//float perturbRad = 0.001
		float differenceSq = dot(differenceVec,differenceVec) + 0.000001;	//small + to avoid /0
		transformedCoord = normalize( transformedCoord + 0.00001*differenceVec/differenceSq );
		
		gl_Position = uPMatrix * ( transformedCoord + vec4(aVertexPosition, vec2(0.)));
	}
</script>


<!-- triplanar texture mapping for voxel terrain -->
<script id="shader-texmap-triplanar-fs" type="x-shader/x-fragment">
#ifdef CUSTOM_DEPTH
	#extension GL_EXT_frag_depth : enable
#endif
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying vec3 veclight;
	varying vec3 vPos;		//3vector position (before mapping onto duocyinder)
	varying vec3 vTexAmounts;
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif	
	void main(void) {		
		float texOffset = 0.5;
		vec3 texColor = mat3(texture2D(uSampler, vec2(vPos.y, vPos.z)).xyz, texture2D(uSampler, vec2(vPos.x, vPos.z + texOffset )).xyz, texture2D(uSampler, vec2(vPos.x + texOffset, vPos.y + texOffset )).xyz) * vTexAmounts;
		
		vec4 preGammaFragColor = vec4( texColor*fog*( veclight + uFogColor.xyz ), 1.0)*uColor + (1.0-fog)*uFogColor;
		
		//tone mapping
		preGammaFragColor = preGammaFragColor/(1.+preGammaFragColor);	
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		//gl_FragColor = vec4( pow(preGammaFragColor.r,0.455), pow(preGammaFragColor.g,0.455), pow(preGammaFragColor.b,0.455), pow(preGammaFragColor.a,0.455));
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
#ifdef CUSTOM_DEPTH
		gl_FragDepthEXT = .5*(vZW.x/vZW.y) + .5;
#endif
	}
</script>
<script id="shader-texmap-perpixel-triplanar-fs" type="x-shader/x-fragment">
#ifdef CUSTOM_DEPTH
	#extension GL_EXT_frag_depth : enable
#endif

	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	uniform vec3 uPlayerLightColor;
	varying float fog;
	uniform vec4 uFogColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	uniform float uSpecularStrength;
	uniform float uSpecularPower;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;	
	varying vec4 vColor;
	varying vec3 vPos;		//3vector position (before mapping onto duocyinder)
	varying vec3 vTexAmounts;
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif		
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
		
		if (posCosDiff>0.0){
			discard;
		}
	
		float texOffset = 0.5;
		vec3 texColor = mat3(texture2D(uSampler, vec2(vPos.y, vPos.z)).xyz, texture2D(uSampler, vec2(vPos.x, vPos.z + texOffset )).xyz, texture2D(uSampler, vec2(vPos.x + texOffset, vPos.y + texOffset )).xyz) * vTexAmounts;
		
		vec4 adjustedPosNormalised = normalize(adjustedPos);

		float light = -dot( adjustedPosNormalised, transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		
#ifdef SPECULAR_ACTIVE
	//other specular implementation is in tangent space.
	//this uses 4vecs. guessed but appears to work fine.
	vec4 eyePos = vec4(0.,0.,0.,1.);
	vec4 vecToEye = normalize(transformedCoord-eyePos);
	vec4 halfVec = normalize( vecToEye + adjustedPosNormalised);
	float phongAmount = uSpecularStrength*pow( max(-dot(halfVec, transformedNormal), 0.),uSpecularPower);
	light*=(1.-uSpecularStrength);	//ensure total light doesn't go -ve
	light+=phongAmount;
#endif
		
		//falloff
		light/=0.1 + 5.0*dot(adjustedPos,adjustedPos);

		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos

#ifdef SPECULAR_ACTIVE
		//TODO take into account "size" of portal light. TODO suspect this is not right - speculat much stronger in shader-texmap-perpixel-discard-normalmap-efficient-fs . suspect due to zeroing w component there
		halfVec = normalize( vecToEye + normalize(transformedCoord-uReflectorPos));
		phongAmount = uSpecularStrength*pow( max(-dot(halfVec, transformedNormal), 0.),uSpecularPower);
		portalLight*=(1.-uSpecularStrength);
		portalLight+=phongAmount;
#endif

		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal

#ifdef VCOLOR
		//vec4 adjustedColor = uColor*vColor;	//TODO this logid in vert shader
		vec4 adjustedColor = uColor;	//temporarily disable this feature -seems input color data broken - some are black. reenable when fix data.
#else
		vec4 adjustedColor = uColor;
#endif
		
		//guess maybe similar to some gaussian light source
		vec4 preGammaFragColor = vec4( fog*( uPlayerLightColor*light + uReflectorDiffColor*portalLight + uFogColor.xyz ), 1.0)*adjustedColor*vec4(texColor,1.) + (1.0-fog)*uFogColor;
				
		//tone mapping
		preGammaFragColor = preGammaFragColor/(1.+preGammaFragColor);	
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		//gl_FragColor = vec4( pow(preGammaFragColor.r,0.455), pow(preGammaFragColor.g,0.455), pow(preGammaFragColor.b,0.455), pow(preGammaFragColor.a,0.455));
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
#ifdef CUSTOM_DEPTH
		gl_FragDepthEXT = .5*(vZW.x/vZW.y) + .5;
#endif
	}
</script>



<script id="shader-texmap-perpixel-normalmap-triplanar-fs" type="x-shader/x-fragment">
#ifdef CUSTOM_DEPTH
	#extension GL_EXT_frag_depth : enable
#endif
	precision mediump float;
	uniform sampler2D uSampler;
	uniform sampler2D uSamplerB;
	uniform vec4 uColor;
	uniform vec3 uPlayerLightColor;
	uniform vec4 uFogColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	uniform float uSpecularStrength;
	uniform float uSpecularPower;

#ifdef VEC_ATMOS_THICK
	varying vec3 fog;
#else	
	varying float fog;
#endif
	varying vec4 vPlayerLightPosTangentSpace;
	varying vec4 vPortalLightPosTangentSpace;
	varying vec4 vEyePosTangentSpace;
	varying vec4 transformedCoord;	
	varying vec4 vColor;
	varying vec3 vPos;		//3vector position (before mapping onto duocyinder)
	varying vec3 vNormal;
	varying vec3 vTexAmounts;
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif	
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
		
		if (posCosDiff>0.0){
			discard;
		}
	
		//discard some pix, see if makes drawing faster
		vec3 vPosMod = ( 100.*vPos - floor(100.*vPos) ) - 0.5;
		float vPosModDot = dot(vPosMod,vPosMod);
		if (vPosModDot<0.2){discard;}

		float texOffset = 0.5;
		
#ifdef DIFFUSE_TEX_ACTIVE
		vec3 texColor = mat3(texture2D(uSamplerB, vec2(vPos.y, vPos.z)).xyz, texture2D(uSamplerB, vec2(vPos.x, vPos.z + texOffset )).xyz, texture2D(uSamplerB, vec2(vPos.x + texOffset, vPos.y + texOffset )).xyz) * vTexAmounts;
#else	
		vec3 texColor = vec3(1.);		//todo use above to combine diffuse with normal map effect
#endif

		float nmapStrength = -0.7;
			//TODO check whether normal maps use linear or sRGB space
			//TODO include ambient occlusion/colour map to match normal map (don't need z component of normal map anyway)

		//sample normal map in different directions.
		//vec3 normsq = sqrt(vNormal*vNormal);	//maybe not exactly right - something to stop texture stretching
		vec3 normsq = abs(vNormal);	//maybe not exactly right - something to stop texture stretching

#ifdef REDUCED_TEXLOOKUPS
		float limitVal = 0.5;	//TODO cleaner transitions. guess should map normsq, then make limitVal ~0
								//TODO also apply to diffuse lookup
		vec3 flatVal = vec3(0.0);
		vec3 nmapA = (normsq.x>limitVal) ? vec3 (texture2D(uSampler, vec2(vPos.y, vPos.z)).xy - vec2(0.5) , 0.0) : flatVal;
		vec3 nmapB = (normsq.y>limitVal) ? vec3 ( texture2D(uSampler, vec2(vPos.x, vPos.z + texOffset )).xy - vec2(0.5) ,0.0) : flatVal;
		vec3 nmapC = (normsq.z>limitVal) ? vec3 ( texture2D(uSampler, vec2(vPos.x + texOffset, vPos.y + texOffset )).xy - vec2(0.5) ,0.0) : flatVal;
#else
		vec3 nmapA = vec3 ( texture2D(uSampler, vec2(vPos.y, vPos.z)).xy - vec2(0.5) , 0.0);	//TODO matrix formulation?
		vec3 nmapB = vec3 ( texture2D(uSampler, vec2(vPos.x, vPos.z + texOffset )).xy - vec2(0.5) ,0.0);
		vec3 nmapC = vec3 ( texture2D(uSampler, vec2(vPos.x + texOffset, vPos.y + texOffset )).xy - vec2(0.5) ,0.0);
#endif
		
		vec3 nmapNormal = normalize( vNormal + nmapStrength * (normsq.x*nmapA.zxy + normsq.y*nmapB.xzy + normsq.z*nmapC.xyz ) );
		
		
		vec4 normalizedLightPos = normalize(vPlayerLightPosTangentSpace);
		vec3 normalizedLightPosAdj = normalize(vPlayerLightPosTangentSpace.xyz);
		
		float light = dot( normalizedLightPosAdj, nmapNormal);	
		
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		
#ifdef SPECULAR_ACTIVE
		vec3 normalizedEyePosAdj = normalize(vEyePosTangentSpace.xyz);	
		
		//float phongAmount = pow(max(dot(normalizedEyePosAdj, nmapNormal),0.),10.);	//simple glossy camera light
		vec3 halfVec = normalize(normalizedEyePosAdj + normalizedLightPosAdj);
		float phongAmount = uSpecularStrength*pow( max(dot(halfVec, nmapNormal), 0.),uSpecularPower);
		light*=(1.-uSpecularStrength);	//ensure total light doesn't go -ve
		light+=phongAmount;
#endif
		
		//falloff
		//	light/=0.1 + 5.0*(1.0-normalizedLightPos.w);				//results consistent with "inefficient" version for small distances
		vec4 vecToLight = normalizedLightPos - vec4(vec3(0.0),1.0);	//result fully consistent with "inefficient" version, but maybe not worth extra calcs
		light/=0.1 + 5.0*dot(vecToLight,vecToLight);

		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		vec3 vPortalLightPosTangentSpaceAdj =normalize(vPortalLightPosTangentSpace.xyz);
		float portalLight = dot( vPortalLightPosTangentSpaceAdj, nmapNormal);
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos

#ifdef SPECULAR_ACTIVE

		//TODO take into account "size" of portal light
		halfVec = normalize( normalizedEyePosAdj + vPortalLightPosTangentSpaceAdj );
		phongAmount = uSpecularStrength*pow( max(dot(halfVec, nmapNormal), 0.),uSpecularPower);
		portalLight*=(1.-uSpecularStrength);	//ensure total light doesn't go -ve
		portalLight+=phongAmount;
#endif

		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal

#ifdef VCOLOR
		//vec4 adjustedColor = uColor*vColor;	//TODO this logid in vert shader
		vec4 adjustedColor = uColor;	//temporarily disable this feature -seems input color data broken - some are black. reenable when fix data.
#else
		vec4 adjustedColor = uColor;
#endif
		
		//guess maybe similar to some gaussian light source
		//vec4 preGammaFragColor = vec4( fog*( uPlayerLightColor*light + uReflectorDiffColor*portalLight + uFogColor.xyz ), 1.0)*adjustedColor*vec4(texColor,1.) + (1.0-fog)*uFogColor;
		vec4 preGammaFragColor = vec4( fog*( uPlayerLightColor*light + uReflectorDiffColor*portalLight + uFogColor.xyz )*adjustedColor.xyz*texColor + (1.0-fog)*uFogColor.xyz , 1.);
				
		//tone mapping
		preGammaFragColor = preGammaFragColor/(1.+preGammaFragColor);	
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		gl_FragColor.a =1.0;
#ifdef CUSTOM_DEPTH
		gl_FragDepthEXT = .5*(vZW.x/vZW.y) + .5;
#endif
	}
</script>






<!-- tex mapped pix shader -->
<script id="shader-texmap-fs" type="x-shader/x-fragment">
	#define CONST_TAU 6.2831853
	#define CONST_REPS 16.0
	
	precision mediump float;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying vec3 veclight;
	varying vec3 vTextureCoord;
	varying vec4 vVertexPos;
	
	void main(void) {
		//gl_FragColor = uColor*texture2D(uSampler, vTextureCoord);

#ifdef MAPPROJECT_ACTIVE
		vec2 newTexCoord = vec2( atan(vVertexPos.x,vVertexPos.y)*CONST_REPS/CONST_TAU, atan(vVertexPos.z,vVertexPos.w)*CONST_REPS/CONST_TAU);
		
		//gl_FragColor = vec4( fog*( veclight + uFogColor.xyz ), 1.0)*uColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		vec4 preGammaFragColor = vec4( fog*( veclight + uFogColor.xyz ), 1.0)*uColor*texture2D(uSampler, newTexCoord) + (1.0-fog)*uFogColor;
#else
		vec4 preGammaFragColor = vec4( fog*( veclight + uFogColor.xyz ), 1.0)*uColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
#endif
		//tone mapping
		preGammaFragColor = preGammaFragColor/(1.+preGammaFragColor);	
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		//gl_FragColor = vec4( pow(preGammaFragColor.r,0.455), pow(preGammaFragColor.g,0.455), pow(preGammaFragColor.b,0.455), pow(preGammaFragColor.a,0.455));
		
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
	}
</script>




<!-- no tex pix shader -->
<script id="shader-flat-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying vec3 veclight;
	
	void main(void) {
		gl_FragColor = vec4( fog*( veclight + uFogColor.xyz ), 1.0)*uColor + (1.0-fog)*uFogColor;
		//gl_FragColor = vec4(1.,0.,0.,1.);
		//gl_FragColor = uColor;
		gl_FragColor.a =1.0;
	}
</script>

<!-- per pixel lighting -->
<!-- expect can make this more efficient -->
<script id="shader-perpixel-fs" type="x-shader/x-fragment">
	//#extension GL_EXT_frag_depth : enable

	precision mediump float;
	uniform vec4 uColor;
	uniform vec3 uEmitColor;
	uniform vec4 uFogColor;
	varying float fog;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	
	void main(void) {
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.1 + 5.0*dot(adjustedPos,adjustedPos);	//1st num some const to ensure light doesn't go inf at short dist
													//guess maybe similar to some gaussian light source
		gl_FragColor = vec4( fog*(( vec3(light) + uFogColor.xyz )*uColor.xyz + uEmitColor), 1.0) + (1.0-fog)*uFogColor;
	}
</script>
<script id="shader-perpixel-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uModelScale;
	varying float fog;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		
		fog = 0.5*(1.0 + transformedCoord.w);
	}
</script>

<!-- discard fragments inside reflector (when rendering cubemap view from inside reflector -->
<script id="shader-perpixel-discard-fs" type="x-shader/x-fragment">
#ifdef CUSTOM_DEPTH
	#extension GL_EXT_frag_depth : enable
#endif
	precision mediump float;
	uniform vec4 uColor;
	uniform vec3 uEmitColor;
	uniform vec3 uPlayerLightColor;
	uniform vec4 uFogColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
#ifdef VEC_ATMOS_THICK
	varying vec3 fog;
#else	
	varying float fog;
#endif
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	varying vec4 transformedCoord;
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif	
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		if (posCosDiff>0.0){
			discard;
		}
	
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.1 + 5.0*dot(adjustedPos,adjustedPos);	//1st num some const to ensure light doesn't go inf at short dist
		
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		float portalLight = dot( uReflectorPos, transformedNormal);
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
		
		
		//ensure isn't something wierd! should be between -1, 1
		//if (portalLight>0.95){portalLight=-0.9;}
		//if (portalLight<-0.95){portalLight=0.9;}
		//portalLight=0.0;
				
		//guess maybe similar to some gaussian light source
		
		//vec4 preGammaFragColor = vec4( fog*(( uPlayerLightColor*light+ uReflectorDiffColor*portalLight + uFogColor.xyz )*uColor.xyz + uEmitColor), 1.0) + (1.0-fog)*uFogColor;
		vec4 preGammaFragColor = vec4( fog*(( uPlayerLightColor*light+ uReflectorDiffColor*portalLight + uFogColor.xyz )*uColor.xyz + uEmitColor) + (1.0-fog)*uFogColor.xyz , 1.0);
		
		//tone mapping
		preGammaFragColor = preGammaFragColor/(1.+preGammaFragColor);	
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		//gl_FragColor = vec4( pow(preGammaFragColor.r,0.455), pow(preGammaFragColor.g,0.455), pow(preGammaFragColor.b,0.455), pow(preGammaFragColor.a,0.455));
		
		gl_FragColor.a =uColor.a;	//TODO confirm check logic for transparent objects
#ifdef CUSTOM_DEPTH
		gl_FragDepthEXT = .5*(vZW.x/vZW.y) + .5;
#endif
	}
</script>
<script id="shader-perpixel-discard-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
#ifdef VEC_ATMOS_THICK
	uniform vec3 uAtmosThickness;
	varying vec3 fog;
#else
	uniform float uAtmosThickness;
	varying float fog;
#endif
	uniform float uAtmosContrast;
#ifdef BENDY_
	uniform mat4 uMMatrixA;
	uniform mat4 uMVMatrixA;
	uniform mat4 uMMatrixB;
	uniform mat4 uMVMatrixB;	//TODO don't have separate mmatrix, mvmatrix x 2 for bendy. should be able to have fewer inputs
#else
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
#endif
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uModelScale;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;
	varying vec4 transformedCoord;
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif	
	void main(void) {	

#ifdef BENDY_

//todo simpler formulation!

vec4 scaledCoord = vec4( uModelScale*aVertexPosition, 1.0);
vec4 xyFlatCoord = normalize(scaledCoord * vec4(1.0,1.0,0.0,1.0));
//vec4 zFlatCoord = scaledCoord * vec4(0.0,0.0,1.0,1.0);	//TODO simply maths by using fact that transformedCoord-flatCoord = ?

vec2 blendWeights = 0.5*(1.0 + aVertexPosition.z*vec2(1.0,-1.0));

vec4 transformedCoordEndA = uMVMatrixA * xyFlatCoord;
vec4 transformedCoordEndB = uMVMatrixB * xyFlatCoord;
vec4 avgCoord1 = blendWeights.x*transformedCoordEndA + blendWeights.y*transformedCoordEndB;

vec4 aVertexPositionNormalizedA = normalize(vec4(uModelScale*(aVertexPosition-vec3(0.0,0.0,1.0)), 1.0));
vec4 aVertexPositionNormalizedB = normalize(vec4(uModelScale*(aVertexPosition+vec3(0.0,0.0,1.0)), 1.0));
vec4 transformedCoordA = uMVMatrixA * aVertexPositionNormalizedA;
vec4 transformedCoordB = uMVMatrixB * aVertexPositionNormalizedB;
vec4 avgCoord2 = blendWeights.x*transformedCoordA + blendWeights.y*transformedCoordB;

float weighting = aVertexPosition.z*aVertexPosition.z;

//transformedCoord = normalize(0.5*(avgCoord1*(1.0-weighting) + avgCoord2*(1.0+weighting)));	//guess, but seems bit wrong at ends
transformedCoord = normalize(0.5*(avgCoord1*(3.0-weighting) + avgCoord2*(3.0+weighting)));	//seems about right. 

vec4 transformedNormalA = uMVMatrixA * vec4(aVertexNormal,0.0);
vec4 transformedNormalB = uMVMatrixB * vec4(aVertexNormal,0.0);
transformedNormal = blendWeights.x*transformedNormalA + blendWeights.y*transformedNormalB;	//approx. TODO use equivalent logic as vertex position

#else
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
#endif

#ifdef CUSTOM_DEPTH
		vZW = vec2(.5*transformedCoord.w, transformedCoord.z-1.);
#endif	
		
		adjustedPos = transformedCoord - uDropLightPos;


		gl_Position = uPMatrix * transformedCoord;
	
#ifdef ATMOS_CONSTANT		
#ifdef VEC_ATMOS_THICK
		fog = vec3(0.5*(1.0 + transformedCoord.w));
#else
		fog = 0.5*(1.0 + transformedCoord.w);
#endif
#else		
#ifdef BENDY_
		vec4 worldCoord = uMMatrixA * aVertexPositionNormalizedA;	//TODO interpolation (currently just using val for 1 matrix)
#else
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;
#endif		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		float total=0.0;
		for (float aa=0.5;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
	}
</script>


<script id="shader-texmap-perpixel-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	
	void main(void) {
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.1 + 5.0*dot(adjustedPos,adjustedPos);
		
		gl_FragColor = vec4( fog*( vec3(light) + uFogColor.xyz ), 1.0)*uColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
	}
</script>

<script id="shader-texmap-perpixel-discard-fs" type="x-shader/x-fragment">
#ifdef CUSTOM_DEPTH
	#extension GL_EXT_frag_depth : enable
#endif
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
#ifdef DEPTH_AWARE
	uniform sampler2D uSamplerDepthmap;
	varying vec3 vScreenSpaceCoord;
#endif
	uniform vec4 uColor;
	uniform vec3 uPlayerLightColor;
#ifdef VEC_ATMOS_THICK
	varying vec3 fog;
#else	
	varying float fog;
#endif
	uniform vec4 uFogColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	uniform float uSpecularStrength;
	uniform float uSpecularPower;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;	
	varying vec4 vColor;
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif	
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		if (posCosDiff>0.0){
			discard;
		}
	
		vec4 adjustedPosNormalised = normalize(adjustedPos);
	
		float light = -dot( adjustedPosNormalised, transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		
#ifdef SPECULAR_ACTIVE
	//other specular implementation is in tangent space.
	//this uses 4vecs. guessed but appears to work fine.
	vec4 eyePos = vec4(0.,0.,0.,1.);
	vec4 vecToEye = normalize(transformedCoord-eyePos);
	vec4 halfVec = normalize( vecToEye + adjustedPosNormalised);
	float phongAmount = uSpecularStrength*pow( max(-dot(halfVec, transformedNormal), 0.),uSpecularPower);
	light*=(1.-uSpecularStrength);
	light+=phongAmount;
#endif
		
		//falloff
		light/=0.1 + 5.0*dot(adjustedPos,adjustedPos);

		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos

#ifdef SPECULAR_ACTIVE
		//TODO take into account "size" of portal light. TODO suspect this is not right - speculat much stronger in shader-texmap-perpixel-discard-normalmap-efficient-fs . suspect due to zeroing w component there
		halfVec = normalize( vecToEye + normalize(transformedCoord-uReflectorPos));
		phongAmount = uSpecularStrength*pow( max(-dot(halfVec, transformedNormal), 0.),uSpecularPower);
		portalLight*=(1.-uSpecularStrength);
		portalLight+=phongAmount;
#endif

		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal

#ifdef VCOLOR
		vec4 adjustedColor = uColor*vColor;	//TODO this logid in vert shader
#else
		vec4 adjustedColor = uColor;
#endif		
		
		//guess maybe similar to some gaussian light source
		//vec4 preGammaFragColor = vec4( fog*( uPlayerLightColor*light + uReflectorDiffColor*portalLight + uFogColor.xyz ), 1.0)*adjustedColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;

		vec4 preGammaFragColor = vec4( fog*( uPlayerLightColor*light + uReflectorDiffColor*portalLight + uFogColor.xyz )*adjustedColor.xyz*texture2DProj(uSampler, vTextureCoord).xyz + (1.0-fog)*uFogColor.xyz , 1.);
		
		//tone mapping
		preGammaFragColor = preGammaFragColor/(1.+preGammaFragColor);	

		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		//gl_FragColor = vec4( pow(preGammaFragColor.r,0.455), pow(preGammaFragColor.g,0.455), pow(preGammaFragColor.b,0.455), pow(preGammaFragColor.a,0.455));
	
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		

#ifdef DEPTH_AWARE
		//preGammaFragColor.rgb = texture2D(uSamplerDepthmap, gl_FragCoord.xy).rgb;	//just something to show can use texture.
		float currentDepth =  texture2DProj(uSamplerDepthmap, vec3(.5,.5,1.)*vScreenSpaceCoord.xyz + vec3(.5,.5,0.)*vScreenSpaceCoord.z).r;
		float newDepth = .5*(vZW.x/vZW.y) + .5;	//this is duplicate of custom depth calculation
		float depthDifference = newDepth - currentDepth;	//TODO calculate actual length difference
		//preGammaFragColor = vec4( vec3(depthDifference) ,1.);	//TODO use coords that project without extra term
		
		gl_FragColor.a = 1.-exp(depthDifference*1000.);
#else
		gl_FragColor.a =1.0;
#endif		


		
#ifdef CUSTOM_DEPTH
		gl_FragDepthEXT = .5*(vZW.x/vZW.y) + .5;
#endif
	}
</script>


<script id="shader-texmap-perpixel-discard-normalmap-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	uniform vec3 uPlayerLightColor;
	varying float fog;
	uniform vec4 uFogColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;
	varying vec4 transformedTangent;
	varying vec4 transformedBinormal;
		
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		if (posCosDiff>0.0){
			discard;
		}
		
		vec3 texSample = texture2DProj(uSampler, vTextureCoord).xyz;
				
		vec3 texSampleAdjusted = texSample*vec3(2.)-vec3(1.);
		texSampleAdjusted.xy*=0.4;	//make surface flatter.
				
		texSampleAdjusted = normalize(texSampleAdjusted);
		
		vec4 nmapNormal = transformedNormal*texSampleAdjusted.z +transformedTangent*texSampleAdjusted.x+ transformedBinormal*texSampleAdjusted.y;	//TODO use matrix for normal, tangent, binormal!
	
		vec4 adjustedColor = pow(uColor, vec4(2.-texSampleAdjusted.z));	//bodge - idea is to make colour deeper in recesses. (TODO special bake for this)
	
		float light = -dot( normalize(adjustedPos), nmapNormal);
		
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		
		
		//falloff
		light/=0.1 + 5.0*dot(adjustedPos,adjustedPos);
		
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, nmapNormal);
	
		
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		//guess maybe similar to some gaussian light source
		vec4 preGammaFragColor = vec4( fog*( uPlayerLightColor*light + uReflectorDiffColor*portalLight + uFogColor.xyz ), 1.0)*adjustedColor + (1.0-fog)*uFogColor;

		//tone mapping
		preGammaFragColor = preGammaFragColor/(1.+preGammaFragColor);		
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));

		gl_FragColor.a =1.0;
	}
</script>


<script id="shader-texmap-perpixel-discard-normalmap-efficient-fs" type="x-shader/x-fragment">
	#define CONST_TAU 6.2831853
	#define CONST_REPS 16.0
#ifdef CUSTOM_DEPTH
	#extension GL_EXT_frag_depth : enable
#endif
	precision mediump float;
	uniform sampler2D uSampler;
	uniform sampler2D uSamplerB;
	uniform sampler2D uSampler2;
	uniform sampler2D uSampler2B;
	uniform vec4 uColor;
	uniform vec3 uPlayerLightColor;
#ifdef VEC_ATMOS_THICK
	varying vec3 fog;
#else	
	varying float fog;
#endif
	uniform vec4 uFogColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	uniform float uSpecularStrength;
	uniform float uSpecularPower;
	uniform float uTexBias;

	varying vec4 vPlayerLightPosTangentSpace;
	varying vec4 vPortalLightPosTangentSpace;
	varying vec4 vEyePosTangentSpace;

	varying vec4 transformedCoord;
	varying vec3 vTextureCoord;
	varying vec4 vVertexPos;
	varying vec4 vColor;
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;	//TODO is transformedcoord still needed if have vPortalLightPosTangentSpace ? 
	
		if (posCosDiff>0.0){
			discard;
		}
		
#ifdef MAPPROJECT_ACTIVE
		vec2 newTexCoord = vec2( atan(vVertexPos.x,vVertexPos.y)*CONST_REPS/CONST_TAU, atan(vVertexPos.z,vVertexPos.w)*CONST_REPS/CONST_TAU);
		vec3 texSample = texture2D(uSampler, newTexCoord).xyz;
#ifdef DOUBLE_TEXTURES
		vec3 texSample2 = texture2D(uSampler, newTexCoord).xyz;
		texSample = mix(texSample, texSample2, vColor.a);	//use tex vertex colour 4th channel
#endif
#else

#ifdef CUSTOM_TEXBIAS
	vec3 texSample = texture2DProj(uSampler, vTextureCoord, uTexBias).xyz;
#else
	vec3 texSample = texture2DProj(uSampler, vTextureCoord).xyz;	//is this case ever used?
#endif

#endif
				
		vec3 texSampleAdjusted = texSample*vec3(2.)-vec3(1.);
		texSampleAdjusted.xy*=0.4;	//make surface flatter.
				
		texSampleAdjusted = normalize(texSampleAdjusted);
		
		vec4 nmapNormal = vec4(texSampleAdjusted,0.0);	//trivial TODO tidy up
		
#ifdef VCOLOR
		vec4 adjustedColor = pow(uColor*vColor, vec4(2.-texSampleAdjusted.z));
#else
		vec4 adjustedColor = pow(uColor, vec4(2.-texSampleAdjusted.z));	//bodge - idea is to make colour deeper in recesses. (TODO special bake for this)
#endif

#ifdef DIFFUSE_TEX_ACTIVE
#ifdef MAPPROJECT_ACTIVE
		//adjustedColor*=texture2D(uSamplerB, newTexCoord);	//hope that 4th component is 1 (opaque). note currently only used in conjunction with MAPPROJECT_ACTIVE
		vec4 diffuseSample=texture2D(uSamplerB, newTexCoord);
#ifdef DOUBLE_TEXTURES
		diffuseSample= mix(diffuseSample, texture2D(uSampler2B, newTexCoord), vColor.a);
		//diffuseSample= mix(diffuseSample, texture2D(uSampler2B, newTexCoord), 0.);
#endif		
		adjustedColor*=pow(diffuseSample,vec4(2.2));	//convert rgb to linear. this is inefficient and expect interpolation won't work right. todo figure out how to use properly, or convert to linear before using in shader.
#else
		adjustedColor*=pow(texture2DProj(uSamplerB, vTextureCoord),vec4(2.2));
#endif
#endif
		
		vec4 normalizedLightPos = normalize(vPlayerLightPosTangentSpace);
		vec4 normalizedLightPosAdj = normalize(vec4( vPlayerLightPosTangentSpace.xyz , 0.0));
		
		float light = dot( normalizedLightPosAdj, nmapNormal);		
		
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		
#ifdef SPECULAR_ACTIVE		
		//add specular component (currently for playerLight only)
		//really should also take into account that light is not point source, especially relevant if apply logic to portal light too, but 
		//	guess if surface not that shiny will work OK with assumption
		//TODO something more efficient. can the halfVec be a varying? what should it be (tried normalising it in vert shader and doesnt interpolate well)
		
		vec4 normalizedEyePosAdj = normalize(vec4( vEyePosTangentSpace.xyz , 0.));	
		light*=(1.-uSpecularStrength);
		//float phongAmount = pow(max(dot(normalizedEyePosAdj, nmapNormal),0.),10.);	//simple glossy camera light
		vec4 halfVec = normalize(normalizedEyePosAdj + normalizedLightPosAdj);
		float phongAmount = uSpecularStrength*pow( max(dot(halfVec, nmapNormal), 0.),uSpecularPower);
		
		light+=phongAmount;
#endif		
		//falloff
	//	light/=0.1 + 5.0*(1.0-normalizedLightPos.w);				//results consistent with "inefficient" version for small distances
		vec4 vecToLight = normalizedLightPos - vec4(vec3(0.0),1.0);	//result fully consistent with "inefficient" version, but maybe not worth extra calcs
		light/=0.1 + 5.0*dot(vecToLight,vecToLight);
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( vPortalLightPosTangentSpace, nmapNormal);
						
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos

#ifdef SPECULAR_ACTIVE
		vec4 vPortalLightPosTangentSpaceAdj = normalize(vec4( vPortalLightPosTangentSpace.xyz , 0.0));

		//TODO take into account "size" of portal light
		halfVec = normalize( normalizedEyePosAdj + vPortalLightPosTangentSpaceAdj );
		phongAmount = uSpecularStrength*pow( max(dot(halfVec, nmapNormal), 0.),uSpecularPower);
		portalLight*=(1.-uSpecularStrength);
		portalLight+=phongAmount;
#endif

		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		//guess maybe similar to some gaussian light source
		//vec4 preGammaFragColor = vec4( fog*( uPlayerLightColor*light + uReflectorDiffColor*portalLight + uFogColor.xyz ), 1.0)*adjustedColor + (1.0-fog)*uFogColor;
		vec4 preGammaFragColor = vec4( fog*( uPlayerLightColor*light + uReflectorDiffColor*portalLight + uFogColor.xyz )*adjustedColor.xyz + (1.0-fog)*uFogColor.xyz , 1.);

		//tone mapping
		preGammaFragColor = preGammaFragColor/(1.+preGammaFragColor);		
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
	

		gl_FragColor.a =1.0;

#ifdef CUSTOM_DEPTH
		gl_FragDepthEXT = .5*(vZW.x/vZW.y) + .5;	//should run from 0->1. TODO varyings that don't require *,+.5
#endif
		//gl_FragDepthEXT = gl_FragCoord.z;	//reproduces standard behaviour. TODO try z/(1+w) for stereographic projection (with some scaling to get inside capped range. 0->1 or -1->1 ?) , to avoid near/far clipping
	}
</script>


<script id="shader-texmap-perpixel-gradlight-discard-fs" type="x-shader/x-fragment">
#ifdef CUSTOM_DEPTH
	#extension GL_EXT_frag_depth : enable
#endif
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform sampler2D uSampler2;
	uniform vec4 uColor;
	uniform vec3 uPlayerLightColor;
	uniform vec4 uOtherLightAmounts;
#ifdef VEC_ATMOS_THICK
	varying vec3 fog;
#else	
	varying float fog;
#endif
	uniform vec4 uFogColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;	
	
	uniform vec3 uLightPosPlayerFrame;	//tmp. TODO do this stuff in v shader
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif
	void main(void) {
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		if (posCosDiff>0.0){
			discard;
		}
	
	/*
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		//falloff
		light/=0.7 + 3.0*dot(adjustedPos,adjustedPos);
	*/
		//tmp remove player light 
	
	/*
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);										
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
		*/
		//todo figure out the above and make lighting in this shader consistent with lighting of other objects
		
		//bodge - treat as if gradient light, where centre colour = uFogColor + 0.5*(uReflectorDiffColor*portalLight), gradient = uReflectorDiffColor*portalLight
		//TODO maybe better to approximate light as some percentage standard directional light, some amount gradient (all gradient at portal surface)
		//maybe quadratic gradient light will be significant improvement (but may require many textures)
		float gradRange = 1.0 / (1.0 + 3.0*dot(posCosDiff,posCosDiff));
		vec3 averageLight = uFogColor.xyz + uReflectorDiffColor * 0.5*gradRange;
			//calculation contribution of gradient lights and sum. this is portalLight vector basically.
		
		//vec3 modifiedLightDirection = vec3(0.5,-0.5,0.0);	//TODO use correct
		vec3 modifiedLightDirection = gradRange*normalize(uLightPosPlayerFrame.xyz);	//TODO scale less when far from portal surf (by difference betwee "average" colour and fog) 
		vec3 modifiedLightDirectionR = modifiedLightDirection*uReflectorDiffColor.r;	//todo matrix notation, do in vert shader
		vec3 modifiedLightDirectionG = modifiedLightDirection*uReflectorDiffColor.g;
		vec3 modifiedLightDirectionB = modifiedLightDirection*uReflectorDiffColor.b;
		
		vec4 vChanWeightsR = vec4(modifiedLightDirectionR, averageLight.r-dot(modifiedLightDirectionR,vec3(0.5)));
		vec4 vChanWeightsG = vec4(modifiedLightDirectionG, averageLight.g-dot(modifiedLightDirectionG,vec3(0.5)));
		vec4 vChanWeightsB = vec4(modifiedLightDirectionB, averageLight.b-dot(modifiedLightDirectionB,vec3(0.5)));
		
		float uMaxAlbedo = 0.4;	//todo use uColor? (baked maps assume some albedo though)
		vChanWeightsR*=uMaxAlbedo;
		vChanWeightsG*=uMaxAlbedo;
		vChanWeightsB*=uMaxAlbedo;	//todo just apply after litColor
		
		vec4 sampleColor = texture2DProj(uSampler, vTextureCoord);
		
		vec3 litColor = vec3( dot(sampleColor, vChanWeightsR), 
								dot(sampleColor, vChanWeightsG),
								dot(sampleColor, vChanWeightsB));
		
		//litColor = vec3(0.0);	//zero lighting to test below stuff
		
		//bodge thruster light by player space light contributon. this is very approximate!
		//todo replace by baked thruster light
		//litColor.b += sampleColor.a;	//isotropic light contribution
		//litColor.b += sampleColor.r;	//light contribution from the left
		//litColor.b += sampleColor.g;	//light contribution from behind
		//litColor.b += sampleColor.b;	//light contribution from below
		vec3 thrustLightColor = vec3(0.1,0.2,0.9)* uOtherLightAmounts.b;
		vec3 gunLightColor = vec3(1.0,1.0,0.1)* uOtherLightAmounts.g;

		vec4 sampleColor2 = texture2DProj(uSampler2, vTextureCoord);

								//TODO matrix formulation
		litColor += thrustLightColor*sampleColor2.b;	//thruster bake
		litColor += gunLightColor*sampleColor2.g;	//gun bake

		//guess maybe similar to some gaussian light source
		//vec4 preGammaFragColor = vec4( fog*( uPlayerLightColor*light + uReflectorDiffColor*portalLight + uFogColor.xyz ), 1.0)*uColor*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		vec4 preGammaFragColor = vec4( fog*litColor + (1.0-fog)*uFogColor.xyz, 1.);

		//tone mapping
		preGammaFragColor = preGammaFragColor/(1.+preGammaFragColor);	
		
		gl_FragColor = pow(preGammaFragColor, vec4(0.455));
		//gl_FragColor = vec4( pow(preGammaFragColor.r,0.455), pow(preGammaFragColor.g,0.455), pow(preGammaFragColor.b,0.455), pow(preGammaFragColor.a,0.455));
	
		
		//gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
		
#ifdef CUSTOM_DEPTH
		gl_FragDepthEXT = .5*(vZW.x/vZW.y) + .5;
		//vec2 normZW=normalize(vZW);
		//gl_FragDepthEXT = .5*(normZW.x/normZW.y) + .5;
#endif
	}
</script>


<!-- vertex shader with tex coords, per pixel -->
<script id="shader-texmap-perpixel-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying float fog;
	uniform vec3 uModelScale;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		
		gl_Position = uPMatrix * transformedCoord;

		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		
		fog = 0.5*(1.0 + transformedCoord.w);

		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>

<script id="shader-texmap-perpixel-discard-normalmap-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	attribute vec3 aVertexTangent;
	attribute vec3 aVertexBinormal;
	varying vec3 vTextureCoord;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying float fog;
	uniform vec3 uModelScale;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;		//note could use mat4 varying to tidy up
	varying vec4 transformedCoord;
	varying vec4 transformedTangent;
	varying vec4 transformedBinormal;
	
	void main(void) {
		vec3 scaledPos = uModelScale*aVertexPosition;
		vec4 aVertexPositionNormalized = normalize(vec4(scaledPos, 1.0));
		vec4 untransformedNormal = normalize( vec4( aVertexNormal, -dot(aVertexNormal, scaledPos)));	
		vec4 untransformedTangent = normalize( vec4( aVertexTangent, -dot(aVertexTangent, scaledPos)));	
		vec4 untransformedBinormal = normalize( vec4( aVertexBinormal, -dot(aVertexBinormal, scaledPos)));	
		
		transformedNormal = uMVMatrix * untransformedNormal;
		transformedTangent = uMVMatrix * untransformedTangent;	
		transformedBinormal = uMVMatrix * untransformedBinormal;
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
		
		gl_Position = uPMatrix * transformedCoord;
		
		/*
		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);	//TODO use matrix for normal, tangent, binormal
		transformedTangent = uMVMatrix * vec4(aVertexTangent,0.0);
		transformedBinormal = uMVMatrix * vec4(aVertexBinormal,0.0);
			//these should be approximately right for small objects.
			//however, really should be something like  normalise( vec4(aVertexPosition + delta*aVertexNormal, 1.0) - aVertexPositionNormalized ) 
			//is there is a neat calculation? are the results any different?
		*/
		adjustedPos = transformedCoord - uDropLightPos;

#ifdef ATMOS_CONSTANT		
		fog = 0.5*(1.0 + transformedCoord.w);		
#else		
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		float total=0.0;
		for (float aa=0.5;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
		
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>


<script id="shader-texmap-perpixel-discard-normalmap-efficient-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	attribute vec3 aVertexTangent;
	attribute vec3 aVertexBinormal;
	attribute vec3 aVertexColor;
	varying vec3 vTextureCoord;
#ifdef VEC_ATMOS_THICK
	uniform vec3 uAtmosThickness;
	varying vec3 fog;
#else
	uniform float uAtmosThickness;
	varying float fog;
#endif
	uniform float uAtmosContrast;
#ifdef VS_MATMULT
	uniform mat4 uVMatrix;
#else
	uniform mat4 uMVMatrix;
#endif
#ifdef INSTANCED
//	attribute mat4 uMMatrix;	//note still using u prefix so can share code with non instanced version
	attribute vec4 aMMatrixA;
	attribute vec4 aMMatrixB;
	attribute vec4 aMMatrixC;
	attribute vec4 aMMatrixD;
#else
	uniform mat4 uMMatrix;
#endif
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uModelScale;
	uniform vec4 uReflectorPosVShaderCopy;	//TODO not this! shouldn't need in both. unsure why need different name. limitation of webgl, or bad assumption in shader loading func?
	
	varying vec4 vPlayerLightPosTangentSpace;
	varying vec4 vPortalLightPosTangentSpace;
	varying vec4 vEyePosTangentSpace;			//does this get skipped automatically if not used?
	
	varying vec4 transformedCoord;
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif	
	void main(void) {
		
		
#ifdef INSTANCED
	//bodge together a matrix from input vectors because suspect chrome bug
		mat4 uMMatrix = mat4( aMMatrixA, aMMatrixB, aMMatrixC, aMMatrixD );
#endif		
		
#ifdef VS_MATMULT
		mat4 MVMatrix = uVMatrix * uMMatrix;
#else
		mat4 MVMatrix = uMVMatrix;
#endif
		
		//transform by normal/tangent/bitangent.
		//this is "efficient" version that moves some work from frag to vertex shader.
		//note could transform the position of lighting objects instead of transforming pos,normal,binormal,tangent, which might be still more efficient.
		vec3 scaledPos = uModelScale*aVertexPosition;
		vec4 untransformedNormal = normalize( vec4( aVertexNormal, -dot(aVertexNormal, scaledPos)));	
		vec4 untransformedTangent = normalize( vec4( aVertexTangent, -dot(aVertexTangent, scaledPos)));	
		vec4 untransformedBinormal = normalize( vec4( aVertexBinormal, -dot(aVertexBinormal, scaledPos)));	
		vec4 aVertexPositionNormalized = normalize(vec4(scaledPos, 1.0));
		
		mat4 vertexMatrix = MVMatrix*mat4(untransformedTangent, untransformedBinormal, untransformedNormal, aVertexPositionNormalized);

		transformedCoord = vertexMatrix[3];
#ifdef CUSTOM_DEPTH
		vZW = vec2(.5*transformedCoord.w, transformedCoord.z-1.);
#endif
		gl_Position = uPMatrix * transformedCoord;
		
		vPlayerLightPosTangentSpace = uDropLightPos*vertexMatrix;
		vPortalLightPosTangentSpace = uReflectorPosVShaderCopy*vertexMatrix;
		
#ifdef SPECULAR_ACTIVE		
		vEyePosTangentSpace = vec4(vec3(0.),1.)*vertexMatrix;
		
		//https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_reflection_model
		//camPosTangentSpace should be normalised already (?? maybe depends on transform+TBN matrix being SO(4)? - but currently just using 3vecs (TODO is this best method?)
		//vPlayerLightHalfwayTangentSpace = vec4(normalize(normalize(vEyePosTangentSpace.xyz) + normalize(vPortalLightPosTangentSpace.xyz)), 0.) ;	//TODO should normalisation take place after interpolation? 	//seems interpolation doesn't work well for this. maybe some trick can do. for now do normalisation in frag shader
#endif	

#ifdef ATMOS_CONSTANT		
#ifdef VEC_ATMOS_THICK
		fog = vec3(0.5*(1.0 + transformedCoord.w));
#else
		fog = 0.5*(1.0 + transformedCoord.w);
#endif
#else		
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		float total=0.0;
		for (float aa=0.5;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
		
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>

<script id="shader-texmap-perpixel-discard-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
	attribute vec3 aVertexVelocity;
	varying vec3 vTextureCoord;
#ifdef VEC_ATMOS_THICK
	uniform vec3 uAtmosThickness;
	varying vec3 fog;
#else
	uniform float uAtmosThickness;
	varying float fog;
#endif
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform float uVertexMove;
	uniform vec3 uModelScale;
	varying vec4 adjustedPos;
	varying vec4 transformedNormal;	
	varying vec4 transformedCoord;
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif
	void main(void) {
#ifdef VERTVEL_ACTIVE
		vec3 shiftedPosition = uModelScale*aVertexPosition + aVertexVelocity*uVertexMove;
		vec4 aVertexPositionNormalized = normalize(vec4(shiftedPosition, 1.0));
#else
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
#endif
		transformedCoord = uMVMatrix * aVertexPositionNormalized;
#ifdef CUSTOM_DEPTH
		vZW = vec2(.5*transformedCoord.w, transformedCoord.z-1.);
#endif
		transformedNormal = uMVMatrix * vec4(aVertexNormal,0.0);
		adjustedPos = transformedCoord - uDropLightPos;
		gl_Position = uPMatrix * transformedCoord;

#ifdef ATMOS_CONSTANT		
#ifdef VEC_ATMOS_THICK
		fog = vec3(0.5*(1.0 + transformedCoord.w));
#else
		fog = 0.5*(1.0 + transformedCoord.w);
#endif
#else		
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		float total=0.0;
		for (float aa=0.5;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
		
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>


<!-- vertex shader with tex coords and 4vector input positions (instead of projected 3vectors.)-->
<script id="shader-texmap-vs-4vec" type="x-shader/x-vertex">
	attribute vec4 aVertexPosition;
	attribute vec4 aVertexNormal;
	attribute vec2 aTextureCoord;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec4 uCameraWorldPos;
	uniform vec3 uPlayerLightColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec3 veclight;
	varying vec4 vVertexPos;
	varying vec3 vTextureCoord;

	void main(void) {
		vec4 transformedCoord = uMVMatrix * aVertexPosition;
		gl_Position = uPMatrix * transformedCoord;
#ifdef ATMOS_CONSTANT		
		fog = 0.5*(1.0 + transformedCoord.w);
#else
		vec4 worldCoord = uMMatrix * aVertexPosition;
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		float total=0.0;
		for (float aa=0.5;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
		vec4 transformedNormal = uMVMatrix * aVertexNormal;
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		light/=1.0 + 4.2*dot(adjustedPos,adjustedPos);		//terms higher than other shaders by sqrt(2) because length
															//of 1,0,0,0 -> 0,1,0,0 (90 deg around world)
															//TODO recalc this since have changed falloff calc in other shaders
		//TODO can process multiple lights using matrix?
		
		veclight=uPlayerLightColor*light;
		
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		veclight+=uReflectorDiffColor*portalLight;

#ifdef MAPPROJECT_ACTIVE
		vVertexPos = aVertexPosition;	//pass through for atan tex mapping (overriding uv)
#else
		vTextureCoord = vec3( aTextureCoord, 1.0 );	
#endif

	}
</script>

<!-- varying stuff merged into shader-texmap-vs-4vec -->
<!-- TODO merge together? -->
<script id="shader-texmap-perpixel-vs-4vec" type="x-shader/x-vertex">	
	attribute vec4 aVertexPosition;
	attribute vec4 aVertexNormal;
	attribute vec2 aTextureCoord;
	attribute vec4 aVertexColor;
#ifdef VEC_ATMOS_THICK
	uniform vec3 uAtmosThickness;
	varying vec3 fog;
#else
	uniform float uAtmosThickness;
	varying float fog;
#endif
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec4 uCameraWorldPos;
	//uniform vec3 uPlayerLightColor;
	//uniform vec3 uReflectorDiffColor;
	//uniform vec4 uReflectorPos;
	//uniform float uReflectorCos;
	//varying vec3 veclight;
	//varying vec4 vVertexPos;
	varying vec4 transformedCoord;
	varying vec4 transformedNormal;
	varying vec3 vTextureCoord;
	varying vec4 vColor;
	varying vec4 adjustedPos;
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif
	void main(void) {
		transformedCoord = uMVMatrix * aVertexPosition;
#ifdef CUSTOM_DEPTH
		vZW = vec2(.5*transformedCoord.w, transformedCoord.z-1.);
#endif
		gl_Position = uPMatrix * transformedCoord;
#ifdef ATMOS_CONSTANT		
#ifdef VEC_ATMOS_THICK
		fog = vec3(0.5*(1.0 + transformedCoord.w));
#else
		fog = 0.5*(1.0 + transformedCoord.w);
#endif
#else
		vec4 worldCoord = uMMatrix * aVertexPosition;
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		float total=0.0;
		for (float aa=0.5;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
		transformedNormal = uMVMatrix * aVertexNormal;
		
#ifdef VCOLOR
		vColor = aVertexColor;	//TODO multiply by uColor in vert shader
#endif
		
		adjustedPos = transformedCoord - uDropLightPos;
		
		//removed per-vertex lighting code
		
		vTextureCoord = vec3( aTextureCoord, 1.0 );	
	}
</script>


<!-- vertex shader with tex coords and 4vector input positions (instead of projected 3vectors.)-->
<script id="shader-texmap-perpixel-normalmap-vs-4vec" type="x-shader/x-vertex">	
	attribute vec4 aVertexPosition;
	attribute vec4 aVertexNormal;
	attribute vec4 aVertexTangent;
	attribute vec4 aVertexBinormal;
	attribute vec2 aTextureCoord;
	attribute vec4 aVertexColor;
#ifdef VEC_ATMOS_THICK
	uniform vec3 uAtmosThickness;
	varying vec3 fog;
#else
	uniform float uAtmosThickness;
	varying float fog;
#endif
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;	//used for atmos calcs. TODO can this be combined with/ used for eyepos calculation (used for specular)?
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec4 uReflectorPosVShaderCopy;
	
	varying vec4 vPlayerLightPosTangentSpace;
	varying vec4 vPortalLightPosTangentSpace;
	varying vec4 vEyePosTangentSpace;
	
	varying vec4 transformedCoord;	
	varying vec3 vTextureCoord;
	varying vec4 vVertexPos;
	varying vec4 vColor;
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif
	void main(void) {
		mat4 vertexMatrix = uMVMatrix*mat4( aVertexTangent, aVertexBinormal, aVertexNormal, aVertexPosition);
		transformedCoord = vertexMatrix[3];
#ifdef CUSTOM_DEPTH
		//vZW = vec2(transformedCoord.z, transformedCoord.w);	
		vZW = vec2(.5*transformedCoord.w, transformedCoord.z-1.);	//w/z from -1 to 1. 	//note that w, z switched from intuitive expectation. see projection matrix. stuff nearest the camera has, at this point, w~1, stuff far away has w~-1, stuff in the middle (looks smallest) w=0. z at this point is like later w, and with sign change. 0 near/far, -1 in middle.
		//TODO can this be got efficiently from gl_FragCoord? what is best point to project from? (this is stereographic projection, but something closer to standard (transformedCoord.z, transformedCoord.w) might be worth it if see close range z-fighting for crossing over polygons. 
#endif
		gl_Position = uPMatrix * transformedCoord;
		vPlayerLightPosTangentSpace = uDropLightPos* vertexMatrix;
		vPortalLightPosTangentSpace = uReflectorPosVShaderCopy*vertexMatrix;
		
#ifdef SPECULAR_ACTIVE
		vEyePosTangentSpace = vec4(vec3(0.),1.)*vertexMatrix;	//eye pos
#endif

#ifdef VCOLOR
		vColor = aVertexColor;	//TODO multiply by uColor in vert shader
#endif

#ifdef ATMOS_CONSTANT		
#ifdef VEC_ATMOS_THICK
		fog = vec3(0.5*(1.0 + transformedCoord.w));
#else
		fog = 0.5*(1.0 + transformedCoord.w);
#endif
#else
		vec4 worldCoord = uMMatrix * aVertexPosition;
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		float total=0.0;
		for (float aa=0.5;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
		
#ifdef MAPPROJECT_ACTIVE
		vVertexPos = aVertexPosition;	//pass through for atan tex mapping (overriding uv)
#else
		vTextureCoord = vec3( aTextureCoord, 1.0 );	//todo pass in unnormalised, use z tex coord for length (and normalise before passing onto frag shader)
#endif

	}
</script>


<script id="shader-texmap-color-triplanar-vs-4vec" type="x-shader/x-vertex">
	//TODO determine whether more efficient to calc aVertexPosition, aVertexNormal from aTriCoord, aTriNormal here in vert shader, or precalc and pass in.
	attribute vec4 aVertexPosition;
	attribute vec4 aVertexNormal;
	attribute vec3 aVertexColor;	//todo 4vec?
	attribute vec3 aTriCoord;
	attribute vec3 aTriNormal;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uPlayerLightColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec3 veclight;
	varying vec3 vPos;		//3vector position (before mapping onto duocyinder)
	varying vec3 vTexAmounts;
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif	
	void main(void) {
		vec4 transformedCoord = uMVMatrix * aVertexPosition;
		gl_Position = uPMatrix * transformedCoord;
#ifdef CUSTOM_DEPTH
		vZW = vec2(.5*transformedCoord.w, transformedCoord.z-1.);
#endif

#ifdef ATMOS_CONSTANT		
		fog = 0.5*(1.0 + transformedCoord.w);
#else
		vec4 worldCoord = uMMatrix * aVertexPosition;
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		float total=0.0;
		for (float aa=0.5;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
		
		
		vec4 transformedNormal = uMVMatrix * aVertexNormal;
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		light/=1.0 + 4.2*dot(adjustedPos,adjustedPos);		//terms higher than other shaders by sqrt(2) because length
															//of 1,0,0,0 -> 0,1,0,0 (90 deg around world)
															//todo recalc
		//TODO can process multiple lights using matrix?
		
		veclight=uPlayerLightColor*light;
		
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		veclight+=uReflectorDiffColor*portalLight;
		veclight*=aVertexColor;
		//veclight=aVertexColor;
				
		//vTexAmounts = vec3(1.0);	//aTriNormal*aTriNormal;
		vPos = aTriCoord;
		vTexAmounts = aTriNormal*aTriNormal;
	}
</script>

<!-- merged shader-texmap-color-triplanar-vs-4vec, shader-texmap-perpixel-vs-4vec -->
<script id="shader-texmap-perpixel-color-triplanar-vs-4vec" type="x-shader/x-vertex">
	//TODO determine whether more efficient to calc aVertexPosition, aVertexNormal from aTriCoord, aTriNormal here in vert shader, or precalc and pass in.
	attribute vec4 aVertexPosition;
	attribute vec4 aVertexNormal;
	attribute vec4 aVertexColor;
	attribute vec3 aTriCoord;
	attribute vec3 aTriNormal;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec4 uCameraWorldPos;
	
	varying float fog;
	varying vec4 transformedCoord;
	varying vec4 transformedNormal;
	varying vec3 vPos;		//3vector position (before mapping onto duocyinder)
	varying vec3 vTexAmounts;
	varying vec4 vColor;
	varying vec4 adjustedPos;
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif	
	void main(void) {
		transformedCoord = uMVMatrix * aVertexPosition;
		gl_Position = uPMatrix * transformedCoord;
#ifdef CUSTOM_DEPTH
		vZW = vec2(.5*transformedCoord.w, transformedCoord.z-1.);
#endif		

#ifdef ATMOS_CONSTANT		
		fog = 0.5*(1.0 + transformedCoord.w);
#else
		vec4 worldCoord = uMMatrix * aVertexPosition;
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		float total=0.0;
		for (float aa=0.5;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
		
		transformedNormal = uMVMatrix * aVertexNormal;
		
#ifdef VCOLOR
		vColor = aVertexColor;	//TODO multiply by uColor in vert shader
#endif
	
		adjustedPos = transformedCoord - uDropLightPos;
		
		vPos = aTriCoord;
		vTexAmounts = aTriNormal*aTriNormal;
	}
</script>
<script id="shader-texmap-perpixel-normalmap-color-triplanar-vs-4vec" type="x-shader/x-vertex">
	//TODO determine whether more efficient to calc aVertexPosition, aVertexNormal from aTriCoord, aTriNormal here in vert shader, or precalc and pass in.
	attribute vec4 aVertexPosition;
	attribute vec4 aVertexNormal;	//AFAIK shouldn't need this, but removing it causes rendering bug. todo find and fix
	attribute vec4 aVertexColor;
	//attribute vec3 aVertexColor;
	attribute vec3 aTriCoord;
	attribute vec3 aTriNormal;
#ifdef VEC_ATMOS_THICK
	uniform vec3 uAtmosThickness;
	varying vec3 fog;
#else
	uniform float uAtmosThickness;
	varying float fog;
#endif
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec4 uCameraWorldPos;
	uniform vec4 uReflectorPosVShaderCopy;
	
	
	varying vec4 vPlayerLightPosTangentSpace;
	varying vec4 vPortalLightPosTangentSpace;
	varying vec4 vEyePosTangentSpace;
	varying vec4 transformedCoord;
	varying vec3 vPos;		//3vector position (before mapping onto duocyinder)
	varying vec3 vTexAmounts;
	varying vec4 vColor;
	varying vec3 vNormal;	
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif	
	void main(void) {
		//calculate vectors moved quarter way around world from this vertex, in the direction of each voxel axis. this is like TBNP "vertexMatrix" matrix, for a normal in one of these directions. (true normal is aVertexNormal though)
		// guess top/bottom world axes x=y=0, z=w=0. up/down turns x,y into z,w. sideways turns x into y and w into z
		float lenRatio = length(aVertexPosition.zw)/length(aVertexPosition.xy);
		vec4 updownaxis = vec4( lenRatio*aVertexPosition.xy , -(1./lenRatio)*aVertexPosition.zw);	//moved up or down from vertex point (not sure sign)
		vec4 sideaxisone = normalize( vec4(aVertexPosition.y, -aVertexPosition.x, 0.,0.));
		vec4 sideaxistwo = normalize( vec4(0.,0., aVertexPosition.w, -aVertexPosition.z));
		
		//zero out some components. expect lighting to be as if projected onto this relative position..
		//mat4 vertexMatrix=uMVMatrix*mat4( vec4(0.), -updownaxis, vec4(0.), aVertexPosition);	//up-down OK
		//mat4 vertexMatrix=uMVMatrix*mat4( sideaxistwo, vec4(0.), vec4(0.), aVertexPosition);	//along tunnel ok	
		mat4 vertexMatrix=uMVMatrix*mat4( sideaxistwo, -updownaxis, sideaxisone, aVertexPosition);
	
		transformedCoord = vertexMatrix[3];		
		gl_Position = uPMatrix * transformedCoord;
#ifdef CUSTOM_DEPTH
		vZW = vec2(.5*transformedCoord.w, transformedCoord.z-1.);
#endif		
		vPlayerLightPosTangentSpace = uDropLightPos* vertexMatrix;
		vPortalLightPosTangentSpace = uReflectorPosVShaderCopy*vertexMatrix;
		
#ifdef SPECULAR_ACTIVE
		vEyePosTangentSpace = vec4(vec3(0.),1.)*vertexMatrix;	//eye pos
#endif
		
		
#ifdef ATMOS_CONSTANT
#ifdef VEC_ATMOS_THICK
		fog = vec3(0.5*(1.0 + transformedCoord.w));
#else
		fog = 0.5*(1.0 + transformedCoord.w);
#endif
#else
		vec4 worldCoord = uMMatrix * aVertexPosition;
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		float total=0.0;
		for (float aa=0.5;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
				
#ifdef VCOLOR
		vColor = aVertexColor;	//TODO multiply by uColor in vert shader
		//vColor = vec4(aVertexColor,1.);	//TODO multiply by uColor in vert shader
#endif
			
		vPos = aTriCoord;
		vNormal = aTriNormal;
		vTexAmounts = aTriNormal*aTriNormal;
	}
</script>

<!-- merge in changes made from shader-texmap-vs-4vec to shader-texmap-perpixel-vs-4vec -->
<script id="shader-texmap-perpixel-vs-duocylinder-sea" type="x-shader/x-vertex">
	#define CONST_TAU 6.2831853
	
	attribute vec2 aVertexPosition;
#ifdef VEC_ATMOS_THICK
	uniform vec3 uAtmosThickness;
	varying vec3 fog;
#else
	uniform float uAtmosThickness;
	varying float fog;
#endif
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform float uTime;
	uniform float uZeroLevel;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	varying vec4 transformedCoord;
	varying vec4 transformedNormal;
	varying vec3 vTextureCoord;
	varying vec4 adjustedPos;
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif
#ifdef DEPTH_AWARE
	varying vec3 vScreenSpaceCoord;
#endif

	void addWaveContribution(in vec2 wavePosIn, inout vec3 wavePosAccum, inout vec3 vDerivativeWRTX, inout vec3 vDerivativeWRTY, float peakiness, vec2 waveCycles){	//waveCycles should be int2
		//wavecycles - number of waves across repeating square in each direction.
		//wavevector relates to this...
		//speed of wave - deep water, speed ~ sqrt(wavelength)
		// wavevector = 2pi/wavelength. wave speed= angularvelocity*wavevector ie (rads/s) / (rads/m)
			//		or speed = frequency*wavelength
			
		// sqrt(wavelength) = angvec * (2pi/wavelength)
		
		//frequency = speed/wavelength ~ sqrt(wavelength)/wavelength = 1/sqrt(wavelength)
		
		//square is 16x16 (TODO make unit square? then can change grid size for fidelity without other messing
		
		//var normalisedGridPos = wavePos
				
		//wavevector is wavecycles * 2PI / square_side_length
		// square_side_length = 1
		
		//wavevector (IIRC direction/wavelength) ~ vec2(n,m), so wavelength = 1/sqrt(n*n+m*m)
		// wavelength = 1/length (wavevector/2PI) = 1/length(wavecycles)
		
		float invWavelength = length(waveCycles);
		
		//since freq and therefore ang vel proportional to 1/invWavelength
		float someConstant = 0.4;	//affects speed of animation
		float freq = someConstant*sqrt(invWavelength);	//<--this why pythagorean tribles not working!
			//unless find triples whose lengths are square! eg 7 24 25, (and 0 1 1, 0 4 4 0 9 9 etc)
		//presumably there is some distribution of wave amplitude with wavelength. for now just try manual terms. IIRC some ratio (since fluid particles circular path)
		//makes pointy waves. therefore pass in "peakiness" - 1 for sharp peak. rolling wheel. 1 revolution in 2pi radii -> pi* peak-to-peak amplitude
		
		//round angfreq so loops? (uTime from 0 to 1 so freq should be integer)
		freq=ceil(freq);
		
		/*
		float phase = CONST_TAU * (uTime*angFreq + dot(waveCycles, wavePosIn.xy));	//TODO should angvel be hardcoded/passed into shader (rather than calc for each vertex)
									//if time is to loop, should ensure waves loop in time - guess by subtle manipulation of angVel (pythagorean triples unrealistic)
		//is this the problem?
		phase=mod(phase,CONST_TAU);	//if works, should mod with 1 before multiplying with CONST_TAU. .... it doesn't work! still glitches!	
		*/
		
		float phase = CONST_TAU* (uTime*freq + dot(waveCycles, wavePosIn));	
		
		float ampl = peakiness/(invWavelength*CONST_TAU);
		wavePosAccum+= ampl*vec3( cos(phase)*waveCycles/invWavelength, sin(phase) );
		
		//add derivative to vDerivativeWRTX, vDerivativeWRTY (TODO combine into matrix?)
		vec3 derivVector = ampl*vec3( -sin(phase)*waveCycles/invWavelength , cos(phase) );	//educated guess TODO proper working
		vDerivativeWRTX += waveCycles.x * derivVector;
		vDerivativeWRTY += waveCycles.y * derivVector;
	}
	
	//ported from tennisBallLoader.js
	vec4 get4vecfrom3vec(in vec3 invec){
		vec2 ang = CONST_TAU * invec.xy;
		float cylr = CONST_TAU * (0.125+ invec.z);
		float sr = sin(cylr);	//todo possible to do this in 1 go? special shader cmmd?
		float cr = cos(cylr);
		return vec4( cr * sin(ang.x), cr * cos(ang.x), sr * sin(ang.y), sr * cos(ang.y) );
	}
	
	void main(void) {
		//1 calc height and normal
		vec3 vDerivativeWRTX = vec3(1./CONST_TAU,0.,0.);
		vec3 vDerivativeWRTY = vec3(0.,1./CONST_TAU,0.);
		
		vec3 vModifiedVertexPosition = vec3( aVertexPosition.xy, uZeroLevel);
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(1.0,9.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(-13.0,2.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(3.0,-7.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(-4.0,5.0));
		
		vec3 surfNorm = normalize(cross(vDerivativeWRTX,vDerivativeWRTY));	//get surface normal by cross product of derivative vectors
				
		//2 convert position and normal to 4vec
		//fake initially to get right vec type
		//vec4 calculatedVertexPosition = vec4(aVertexPosition, 0.,0.);
		vec4 calculatedVertexPosition = get4vecfrom3vec(vModifiedVertexPosition);
		
		//simple way to calc norms - move a little along normal, subtract this from original value, normalise the result.
		//probably can express as a derivative wrt normal movment, then normalise result, but this way is easier.
		vec4 shiftedVertexPosition = get4vecfrom3vec(vModifiedVertexPosition+.001*surfNorm);
		vec4 calculatedVertexNormal = normalize(shiftedVertexPosition - calculatedVertexPosition);
		
		//3 use thse values same as in shader-texmap-vs-4vec
		transformedCoord = uMVMatrix * calculatedVertexPosition;
#ifdef CUSTOM_DEPTH
		vZW = vec2(.5*transformedCoord.w, transformedCoord.z-1.);
#endif
		gl_Position = uPMatrix * transformedCoord;
		
#ifdef ATMOS_CONSTANT
#ifdef VEC_ATMOS_THICK
		fog = vec3(0.5*(1.0 + transformedCoord.w));
#else
		fog = 0.5*(1.0 + transformedCoord.w);
#endif
#else
		vec4 worldCoord = uMMatrix * calculatedVertexPosition;
		/*
		float dotProd = dot(uCameraWorldPos,worldCoord);
		float maxAng = acos(dotProd);	//angle from camera to object
		float maxAngOverIters = maxAng/CONST_ITERS;
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		float totalPath=0.0;
		float currentAngle;
		vec4 currentPos;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			currentAngle=maxAngOverIters*aa;
			currentPos = uCameraWorldPos*cos(currentAngle)+normalDirection*sin(currentAngle);
			totalPath+=exp(uAtmosContrast*dot(currentPos.xy,currentPos.xy));	//number here affects how different atmos pressure is between extremes
		}
		fog=exp(-totalPath*uAtmosThickness*maxAngOverIters);
		*/
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif		
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		float total=0.0;
		for (float aa=0.5;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
	
		transformedNormal = uMVMatrix * calculatedVertexNormal;
		adjustedPos = transformedCoord - uDropLightPos;
		
		vTextureCoord = vec3( aVertexPosition, 1.0 );	//any point in projected tex??
		
#ifdef DEPTH_AWARE
		vScreenSpaceCoord = gl_Position.xyw;
#endif
	}
</script>

<script id="shader-texmap-vs-duocylinder-sea" type="x-shader/x-vertex">
	#define CONST_TAU 6.2831853
	
	attribute vec2 aVertexPosition;
	uniform float uAtmosThickness;
	uniform float uAtmosContrast;
	uniform mat4 uMMatrix;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform float uTime;
	uniform float uZeroLevel;
	uniform vec4 uCameraWorldPos;
	uniform vec4 uDropLightPos;	//position in camera frame ( 0,0,0,1 if light at camera )
	uniform vec3 uPlayerLightColor;
	uniform vec3 uReflectorDiffColor;
	uniform vec4 uReflectorPos;
	uniform float uReflectorCos;
	varying float fog;
	varying vec3 veclight;
	
	varying vec3 vTextureCoord;
	
	void addWaveContribution(in vec2 wavePosIn, inout vec3 wavePosAccum, inout vec3 vDerivativeWRTX, inout vec3 vDerivativeWRTY, float peakiness, vec2 waveCycles){	//waveCycles should be int2
		//wavecycles - number of waves across repeating square in each direction.
		//wavevector relates to this...
		//speed of wave - deep water, speed ~ sqrt(wavelength)
		// wavevector = 2pi/wavelength. wave speed= angularvelocity*wavevector ie (rads/s) / (rads/m)
			//		or speed = frequency*wavelength
			
		// sqrt(wavelength) = angvec * (2pi/wavelength)
		
		//frequency = speed/wavelength ~ sqrt(wavelength)/wavelength = 1/sqrt(wavelength)
		
		//square is 16x16 (TODO make unit square? then can change grid size for fidelity without other messing
		
		//var normalisedGridPos = wavePos
				
		//wavevector is wavecycles * 2PI / square_side_length
		// square_side_length = 1
		
		//wavevector (IIRC direction/wavelength) ~ vec2(n,m), so wavelength = 1/sqrt(n*n+m*m)
		// wavelength = 1/length (wavevector/2PI) = 1/length(wavecycles)
		
		float invWavelength = length(waveCycles);
		
		//since freq and therefore ang vel proportional to 1/invWavelength
		float someConstant = 0.4;	//affects speed of animation
		float freq = someConstant*sqrt(invWavelength);	//<--this why pythagorean tribles not working!
			//unless find triples whose lengths are square! eg 7 24 25, (and 0 1 1, 0 4 4 0 9 9 etc)
		//presumably there is some distribution of wave amplitude with wavelength. for now just try manual terms. IIRC some ratio (since fluid particles circular path)
		//makes pointy waves. therefore pass in "peakiness" - 1 for sharp peak. rolling wheel. 1 revolution in 2pi radii -> pi* peak-to-peak amplitude
		
		//round angfreq so loops? (uTime from 0 to 1 so freq should be integer)
		freq=ceil(freq);
		
		/*
		float phase = CONST_TAU * (uTime*angFreq + dot(waveCycles, wavePosIn.xy));	//TODO should angvel be hardcoded/passed into shader (rather than calc for each vertex)
									//if time is to loop, should ensure waves loop in time - guess by subtle manipulation of angVel (pythagorean triples unrealistic)
		//is this the problem?
		phase=mod(phase,CONST_TAU);	//if works, should mod with 1 before multiplying with CONST_TAU. .... it doesn't work! still glitches!	
		*/
		
		float phase = CONST_TAU* (uTime*freq + dot(waveCycles, wavePosIn));	
		
		float ampl = peakiness/(invWavelength*CONST_TAU);
		wavePosAccum+= ampl*vec3( cos(phase)*waveCycles/invWavelength, sin(phase) );
		
		//add derivative to vDerivativeWRTX, vDerivativeWRTY (TODO combine into matrix?)
		vec3 derivVector = ampl*vec3( -sin(phase)*waveCycles/invWavelength , cos(phase) );	//educated guess TODO proper working
		vDerivativeWRTX += waveCycles.x * derivVector;
		vDerivativeWRTY += waveCycles.y * derivVector;
	}
	
	//ported from tennisBallLoader.js
	vec4 get4vecfrom3vec(in vec3 invec){
		vec2 ang = CONST_TAU * invec.xy;
		float cylr = CONST_TAU * (0.125+ invec.z);
		float sr = sin(cylr);	//todo possible to do this in 1 go? special shader cmmd?
		float cr = cos(cylr);
		return vec4( cr * sin(ang.x), cr * cos(ang.x), sr * sin(ang.y), sr * cos(ang.y) );
	}
	
	void main(void) {
		//1 calc height and normal
		vec3 vDerivativeWRTX = vec3(1./CONST_TAU,0.,0.);
		vec3 vDerivativeWRTY = vec3(0.,1./CONST_TAU,0.);
		
		vec3 vModifiedVertexPosition = vec3( aVertexPosition.xy, uZeroLevel);
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(1.0,9.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(-13.0,2.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(3.0,-7.0));
		addWaveContribution(aVertexPosition, vModifiedVertexPosition, vDerivativeWRTX, vDerivativeWRTY, 0.15, vec2(-4.0,5.0));
		
		vec3 surfNorm = normalize(cross(vDerivativeWRTX,vDerivativeWRTY));	//get surface normal by cross product of derivative vectors
				
		//2 convert position and normal to 4vec
		//fake initially to get right vec type
		//vec4 calculatedVertexPosition = vec4(aVertexPosition, 0.,0.);
		vec4 calculatedVertexPosition = get4vecfrom3vec(vModifiedVertexPosition);
		
		//simple way to calc norms - move a little along normal, subtract this from original value, normalise the result.
		//probably can express as a derivative wrt normal movment, then normalise result, but this way is easier.
		vec4 shiftedVertexPosition = get4vecfrom3vec(vModifiedVertexPosition+.001*surfNorm);
		vec4 calculatedVertexNormal = normalize(shiftedVertexPosition - calculatedVertexPosition);
		
		//3 use thse values same as in shader-texmap-vs-4vec
		vec4 transformedCoord = uMVMatrix * calculatedVertexPosition;
		
		gl_Position = uPMatrix * transformedCoord;
		
#ifdef ATMOS_CONSTANT
		fog = 0.5*(1.0 + transformedCoord.w);
#else
		vec4 worldCoord = uMMatrix * calculatedVertexPosition;
		/*
		float dotProd = dot(uCameraWorldPos,worldCoord);
		float maxAng = acos(dotProd);	//angle from camera to object
		float maxAngOverIters = maxAng/CONST_ITERS;
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		float totalPath=0.0;
		float currentAngle;
		vec4 currentPos;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			currentAngle=maxAngOverIters*aa;
			currentPos = uCameraWorldPos*cos(currentAngle)+normalDirection*sin(currentAngle);
			totalPath+=exp(uAtmosContrast*dot(currentPos.xy,currentPos.xy));	//number here affects how different atmos pressure is between extremes
		}
		fog=exp(-totalPath*uAtmosThickness*maxAngOverIters);
		*/
		
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float maxDoubleAng = 2.0*acos(dotProd);
#endif		
#ifdef ATMOS_ONE
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		float total=0.0;
		for (float aa=0.5;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);
#endif
#ifdef ATMOS_TWO
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
	
		vec4 transformedNormal = uMVMatrix * calculatedVertexNormal;
		vec4 adjustedPos = transformedCoord - uDropLightPos;
		float light = -dot( normalize(adjustedPos), transformedNormal);
		light = max(light,0.0);	//unnecessary if camera pos = light pos
		light/=1.0 + 4.2*dot(adjustedPos,adjustedPos);		//terms higher than other shaders by sqrt(2) because length
															//of 1,0,0,0 -> 0,1,0,0 (90 deg around world)
															//todo recalc
		veclight=uPlayerLightColor*light;
		
		float posCosDiff = dot(normalize(transformedCoord),uReflectorPos) - uReflectorCos;
	
		//light from portal. TODO pass in a colour for this, more complex lighting (at surface of portal, should be hemispherical light etc)
		//this is just bodged/guessed to achieve correct behaviour at/across portal. TODO check/correct!
		float portalLight = dot( uReflectorPos, transformedNormal);
		portalLight = max(0.5*portalLight +0.5+ posCosDiff,0.0);	//unnecessary if camera pos = light pos
		//falloff
		portalLight/=1.0 + 3.0*dot(posCosDiff,posCosDiff);	//just something that's 1 at edge of portal
				
		veclight+=uReflectorDiffColor*portalLight;
		
		vTextureCoord = vec3( aVertexPosition, 1.0 );	//any point in projected tex??
	}
</script>

<!-- simple cubemap pix shader -->
<script id="shader-cubemap-fs" type="x-shader/x-fragment">
#ifdef CUSTOM_DEPTH
	#extension GL_EXT_frag_depth : enable
#endif
	precision mediump float;
	uniform samplerCube uSampler;
	varying vec3 vPos;
#ifdef VEC_ATMOS_THICK
	varying vec3 fog;
#else	
	varying float fog;
#endif
	uniform vec4 uColor;	//TODO remove? (should be white, but useful to tint for debug/ coloured reflector)
	uniform vec4 uFogColor;
	uniform float uPortalRad;
	varying vec3 vScreenSpaceCoord;
	uniform vec4 uPortalCameraPos;	//for "special" 
	uniform vec2 uFNumber;
	uniform mat4 uMVMatrixFSCopy;
	uniform vec3 uCentrePosScaledFSCopy;
	uniform mat4 uPortaledMatrix;
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif	
	void main(void) {
		//gl_FragColor = uColor*textureCube(uSampler, vPos);	//TODO use this (get rid of fog)

#ifndef SPECIAL
#ifndef VPROJ_MIX
		vec3 preGammaFragColor = pow(textureCube(uSampler, vPos).xyz,vec3(2.2));
#else
		vec2 interpCoords = vScreenSpaceCoord.xy/vScreenSpaceCoord.z;
		vec4 pointingDirection = normalize(vec4(-uFNumber*interpCoords,1.,0.));

		//a simpler bodge might be to just use simple "movement" of camera thru portal where close to it (shaky regime). blend between the two.
		vec4 simplePlanarPortalDir = pointingDirection*uPortaledMatrix;
		
		float closeness = dot(uCentrePosScaledFSCopy,uCentrePosScaledFSCopy);	//something that goes to 1 in shaky regime, 0 outside
		closeness = pow(closeness,6.);
		vec3 preGammaFragColor = pow(textureCube(uSampler, vPos - 0.05*closeness*simplePlanarPortalDir.xyz).xyz,vec3(2.2));	//simplePlanar will become dominant when other term small
#endif
#else
		//preGammaFragColor.rg*=0.5*(1.+sin(10.*vScreenSpaceCoord));
		vec2 interpCoords = vScreenSpaceCoord.xy/vScreenSpaceCoord.z;
		vec2 portalCameraCoords = uPortalCameraPos.xy/uPortalCameraPos.z;	//calculating from uniform every pixel is bad!
		vec2 screenDifference = uFNumber*interpCoords + portalCameraCoords;
		
		vec4 position = vec4(vec3(0.),1.);									//for camera in camera space
		vec4 pointingDirection = normalize(vec4(-uFNumber*interpCoords,1.,0.));
		
		//convert these into portal space. TODO do this in vertex shader and benefit from interpolation
		vec4 posA = position * uMVMatrixFSCopy;		//this is posA in main.js:testRayBallCollision
		vec4 posB = pointingDirection * uMVMatrixFSCopy;	//posB in ""
	
		float maxwsq = posA.w*posA.w + posB.w*posB.w;
		float radsq = uPortalRad*uPortalRad;
		float critwsq = 1./(1.+radsq);
		
		if (maxwsq<critwsq){
			discard;
		}
		
		float invmaxw = 1./sqrt(maxwsq);
		vec4 closeApproach = invmaxw * (posA*posA.w + posB*posB.w);	//TODO combo mult by invmaxw here and later
		vec4 equatorVec = - invmaxw * (posB*posA.w - posA*posB.w);

		float projectedradiussq = (1.-maxwsq)/maxwsq;
		float correction = sqrt( radsq - projectedradiussq );
		vec4 collisonPoint = invmaxw*closeApproach - correction*equatorVec;

		//simple test
		vec3 scaledPoint = 10.*(normalize(-collisonPoint.xyz)+1.);
		scaledPoint = scaledPoint - floor(scaledPoint);
	//	vec3 preGammaFragColor = scaledPoint;	//looks solid!

		//no mix version
	//	vec3 preGammaFragColor = pow(textureCube(uSampler, normalize(-collisonPoint.xyz) - uCentrePosScaledFSCopy).xyz,vec3(2.2));

		//mix with simple planar (avoids wobbles at close range)
		vec4 simplePlanarPortalDir = pointingDirection*uPortaledMatrix;
		float closeness = dot(uCentrePosScaledFSCopy,uCentrePosScaledFSCopy);	//something that goes to 1 in shaky regime, 0 outside
		closeness = pow(closeness,6.);
		vec3 preGammaFragColor = pow(textureCube(uSampler, normalize(-collisonPoint.xyz) - uCentrePosScaledFSCopy - 0.05*closeness*simplePlanarPortalDir.xyz).xyz,vec3(2.2));	//simplePlanar will become dominant when other term small


#endif
		
		//undo tone mapping . y=1/(1+x) => x=y/(1-y)
		//seems like in practice, undoing, redoing tone mapping has little value, but guess because currently not using very bright lighting.
		//TODO check whether still need this - 
		
		vec3 preToneMap = preGammaFragColor / (1.001 - preGammaFragColor);	//using 1.001 instead of 1 to prevent /0 problems
		//preToneMap = vec3(fog)*uColor.xyz*preToneMap + (1.0-fog)*uFogColor.xyz;
		preToneMap = fog*uColor.xyz*preToneMap + (1.0-fog)*uFogColor.xyz;
		
		//reapply tone mapping
		preGammaFragColor = preToneMap/(1.+preToneMap);
		
		gl_FragColor = vec4( pow(preGammaFragColor, vec3(0.455)) , 1.0);
		
#ifdef CUSTOM_DEPTH
		gl_FragDepthEXT = .5*(vZW.x/vZW.y) + .5;
		//vec2 normZW= normalize(vZW);
		//gl_FragDepthEXT = .5*(normZW.x/normZW.y) + .5;
#endif
}

</script>
<!-- vertex shader -->
<script id="shader-cubemap-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	varying vec3 vPos;
	uniform vec3 uModelScale;
	uniform mat4 uPosShiftMat;
	uniform float uPolarity;

#ifdef VEC_ATMOS_THICK
	uniform vec3 uAtmosThickness;
	varying vec3 fog;
#else
	uniform float uAtmosThickness;
	varying float fog;
#endif
	uniform float uAtmosContrast;	//atmos variants specific
	uniform mat4 uMMatrix;
	uniform vec4 uCameraWorldPos;

	uniform vec3 uCentrePosScaled;	//vertproj specific. this is position of cubemap centre point in unprojected model space
	
	varying vec3 vScreenSpaceCoord;
#ifdef CUSTOM_DEPTH
	varying vec2 vZW;
#endif

	void main(void) {
#ifdef VERTPROJ
		float csq = dot(uCentrePosScaled,uCentrePosScaled);
		float cdotp = dot(uCentrePosScaled, -aVertexPosition);
		float a = pow((1.0-csq)+cdotp*cdotp, 0.5) - cdotp;
		vec3 scaledVertexPosition = aVertexPosition*a;
	
		vec4 aVertexPositionNormalized = normalize(vec4( uModelScale*(scaledVertexPosition-uCentrePosScaled), 1.0));	
#else
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));	//project 3d object onto 3sphere
																//can avoid this by inputting 4vector positions *...
#endif
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
#ifdef CUSTOM_DEPTH
		vZW = vec2(.5*transformedCoord.w, transformedCoord.z-1.);
#endif
#ifdef ATMOS_CONSTANT
#ifdef VEC_ATMOS_THICK
		fog = vec3(0.5*(1.0 + transformedCoord.w));
#else
		fog = 0.5*(1.0 + transformedCoord.w);
#endif
#else
		vec4 worldCoord = uMMatrix * aVertexPositionNormalized;
#endif
#ifdef ATMOS_ONE
		//calculcate position on surface of portal if camera is inside portal. 
		//todo can this be calculated more efficiently along with other terms?
		//float fudgeSizeVal = 0.953; 	//above this w component inside portal. expect this for portal scale =0.3 because root(1-0.3*0.3). 
										//todo pass through portal size
		float fudgeSizeVal = 0.96; 	//works better, guess because problems with approximation
		vec4 rayStart = uCameraWorldPos;
		if (uCameraWorldPos.w > fudgeSizeVal){	//can lose if here if separate shader for within/out portal
			//dumb approximation, should work for small distances - just find where line from start to end intersects plane for w=fudgeSizeVal
			vec4 midpoint = vec4( ((uCameraWorldPos.w - fudgeSizeVal)*worldCoord.xyz + (fudgeSizeVal - worldCoord.w)*uCameraWorldPos.xyz)/(uCameraWorldPos.w-worldCoord.w) , fudgeSizeVal);
			rayStart = normalize(midpoint);	
		}
		
		/*
		fog = 0.5*(1.0 + transformedCoord.w);
		//note 1.0 = no fog, 0 = total fog.
		//more complex fog calculation. show that can have radial dependence. not anything like physically correct!
		float airDensityAtObj = exp(-dot(worldCoord.xy,worldCoord.xy));
		fog*=airDensityAtObj; 
		*/
		
		//although this is used for "per pixel" version, currently calculating fog per vertex.
		
		/*
		float dotProd = dot(uCameraWorldPos,worldCoord);
		float maxAng = acos(dotProd*0.999);	//angle from camera to object
		float maxAngOverIters = maxAng/CONST_ITERS;
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		float totalPath=0.0;
		float currentAngle;
		vec4 currentPos;
		for (float aa=0.0;aa<CONST_ITERS;aa++){
			currentAngle=maxAngOverIters*aa;
			currentPos = uCameraWorldPos*cos(currentAngle)+normalDirection*sin(currentAngle);
			totalPath+=exp(uAtmosContrast*dot(currentPos.xy,currentPos.xy));	//number here affects how different atmos pressure is between extremes
		}
		fog=exp(-totalPath*uAtmosThickness*maxAngOverIters);
		*/
	
		float dotProd = dot(rayStart,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*rayStart);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(rayStart.xy, rayStart.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(rayStart.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd*0.999);
		float maxDoubleAngOverIters = maxDoubleAng/CONST_ITERS;
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float total=0.0;
		for (float aa=0.5;aa<CONST_ITERS;aa++){
			float rsq = magTerm*sin(aa*maxDoubleAngOverIters+shiftAngle);
			total+= exp(uAtmosContrast*rsq);
		}
		total*= maxDoubleAngOverIters*exp(uAtmosContrast*(constTerm));	
		fog = exp(-uAtmosThickness*total/2.0);

#endif
#ifdef ATMOS_TWO
		float dotProd = dot(uCameraWorldPos,worldCoord);
		
		vec4 normalDirection = normalize(worldCoord - dotProd*uCameraWorldPos);	//point 90 deg around world from camera, in direction of worldCoord
		
		float partOne = dot(uCameraWorldPos.xy, uCameraWorldPos.xy);
		float partTwo = dot(normalDirection.xy, normalDirection.xy);
		float constTerm = (partOne+partTwo)/2.0;
		float cos2Term = (partOne-partTwo)/2.0;
		float sin2Term = dot(uCameraWorldPos.xy, normalDirection.xy);
		float shiftAngle = atan(cos2Term,sin2Term);
		
		float maxDoubleAng = 2.0*acos(dotProd*0.999);
		
		//float magTerm = sqrt(cos2Term*cos2Term+sin2Term*sin2Term);
		float magTerm = length(vec2(cos2Term, sin2Term));
		
		float kk = magTerm * uAtmosContrast;
		float ksq = kk*kk;

		float maxA = maxDoubleAng+shiftAngle;

		float kcxa = kk*cos(maxA);
		float kcxb = kk*cos(shiftAngle);
		float ksxa = kk*sin(maxA);
		float ksxb = kk*sin(shiftAngle);
		float kcxasq=kcxa*kcxa;
		float kcxbsq=kcxb*kcxb;
		
		float integral=(1.0+ksq/4.0 + ksq*ksq/64.0)*(maxA -shiftAngle);
		integral-= (1.0+ksq/8.0)*(kcxa-kcxb);
		integral-=(ksq/48.0+0.25)*(kcxa*ksxa - kcxb*ksxb);
		integral+=(kcxa*kcxasq - kcxb*kcxbsq)*(4.0/72.0);
		integral-=ksq*(kcxa -kcxb)*(3.0/72.0);
		integral+=(4.0/768.0)*((2.0*kcxasq-ksq)*kcxa*ksxa -(2.0*kcxbsq-ksq)*kcxb*ksxb);

		float total=integral*exp(uAtmosContrast*constTerm);
		fog = exp(-uAtmosThickness*total/2.0);
#endif
	
		//gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); // *... or can just use 1.0 without normalising? TODO try.
		gl_Position = uPMatrix * transformedCoord;
		vPos = uPolarity * (uPosShiftMat*aVertexPositionNormalized).xyz;
		
#ifdef SPECIAL
		vScreenSpaceCoord = gl_Position.xyw;
		//next up - uniform to contain the camera space position of the portal
		//and fx/fy. step 1 indicate by colour difference between screen coord and position on screen of portal.
		//then work out how far from centre line of sighy passed. expect be able to draw concentric circles 
		
#endif
	}
</script>


<script type="text/javascript" src="js/main.js"></script>


</head>

<body onload="init()">
<div id="info">3-sphere visualised in WebGL demo. Arrow keys, QE, click+drag mouse to rotate. WASD, space/ctrl to translate.<a href="https://github.com/filbs111/3sphere-explorer" target="_blank">https://github.com/filbs111/3sphere-explorer</a></div>
<div id="info2" class="debuginfo" style="display:none">TEST</div>
<div id="info3" class="debuginfo" style="display:none">GC INFO TO GO HERE. IF SEE NOTHING, TRY A CHROMIUM BROWSER</div>
		
<!--<svg style="position:absolute;background:#0000;left:780px;top:330px" height="200" width="200">
  <circle cx="100" cy="100" r="80" stroke="yellow" stroke-width="2" fill="none" />
  <circle cx="100" cy="100" r="5" stroke="yellow" stroke-width="2" fill="none" />
</svg>-->
<canvas id="mycanvas" width="0" height="0">CANVAS TO GO HERE</canvas>


</body>


</html>