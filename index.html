<!DOCTYPE html>
<html>

<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<title>3-sphere explorer</title>

<style>
	body {
		margin: 0px;
		overflow: hidden;
	}

	#info {
		position: absolute;
		top: 0px; width: 100%;
		padding: 20px;
		color: white;
		text-align: center;
	}
	
	#info a:link {
				color: white;
	}
		
	#info a:visited {
		color: white;
	}
</style>

<script type="text/javascript" src="lib/dat.gui.min.js"></script>
<script type="text/javascript" src="lib/stats.min.js"></script>
<script type="text/javascript" src="lib/gl-matrix-min.js"></script>
<script type="text/javascript" src="utils/webgl_utils.js"></script>
<script type="text/javascript" src="data/sphere.js"></script>
<script type="text/javascript" src="data/levelCubeData.js"></script>
<script type="text/javascript" src="data/tennisBall.js"></script>
<script type="text/javascript" src="data/cube-frame-a1-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/octohedron-nosubdiv-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/tetra-frame.obj.json"></script>
<script type="text/javascript" src="data/dodecahedron-frame-cubeproj.obj.json"></script>
<script type="text/javascript" src="data/wt_teapot-trimmed.obj.json"></script>
<script type="text/javascript" src="data/sship-ypoint.obj.json"></script>
<script type="text/javascript" src="data/guncyl.obj.json"></script>
<script type="text/javascript" src="utils/matfuncs.js"></script>
<script type="text/javascript" src="data/cells.js"></script>

<!-- simple pix shader -->
<script id="shader-simple-fs" type="x-shader/x-fragment">
	//#extension GL_EXT_frag_depth : enable

	precision mediump float;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	varying float light;
	
	void main(void) {
		gl_FragColor = vec4( fog*light*uColor.xyz, 1.0) + (1.0-fog)*uFogColor;
	}
</script>
<!-- vertex shader -->
<!-- note that taking in 3vector for vertex positions since generally objects are significantly smaller than the 3-sphere radius, so can project them onto unit 3sphere
(set w=1 and normalise to r=1) or j ust set w=1. --> 
<!-- if normalisation is used, i expect will be more efficient to generate 4-vector vertiex buffers and pass those in -->
<!-- mvmatrix will be an SO4 matrix. pmatrix will try a standard projection matrix -->
<!-- possibly want to output additional varying to pass some depth variable -->
<!-- TODO use textured shader to check that that interpolates in sensible way (ie perspective projection observed for rectangles). -->
<script id="shader-simple-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	varying float fog;
	uniform vec3 uModelScale;
	varying float light;
			
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		gl_Position = uPMatrix * transformedCoord;

		vec4 transformedNormal = uMVMatrix * normalize(vec4(aVertexNormal,1.0));
		light = max(dot(transformedNormal, aVertexPositionNormalized) , 0.0);	//irrelevant if light position = camera position ?
		
		fog = 0.5*(1.0 + transformedCoord.w);
	}
</script>


<!-- tex mapped pix shader -->
<script id="shader-texmap-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec3 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uColor;
	varying float fog;
	uniform vec4 uFogColor;
	
	void main(void) {
		//gl_FragColor = uColor*texture2D(uSampler, vTextureCoord);
		
		gl_FragColor = uColor*fog*texture2DProj(uSampler, vTextureCoord) + (1.0-fog)*uFogColor;
		//gl_FragColor = (1.0-fog)*uFogColor;
		gl_FragColor.a =1.0;
	}
</script>
<!-- vertex shader with tex coords -->
<script id="shader-texmap-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	varying float fog;
	uniform vec3 uModelScale;
	
	void main(void) {
		vec4 aVertexPositionNormalized = normalize(vec4(uModelScale*aVertexPosition, 1.0));
		vec4 transformedCoord = uMVMatrix * aVertexPositionNormalized;
		
		gl_Position = uPMatrix * transformedCoord;

		fog = 0.5*(1.0 + transformedCoord.w);
		
		float myZ = aVertexPositionNormalized.w;
		vTextureCoord = vec3( aTextureCoord.st*myZ, myZ );
	}
</script>


<!-- vertex shader with tex coords and 4vector input positions (instead of projected 3vectors.)-->
<script id="shader-texmap-vs-4vec" type="x-shader/x-vertex">
	attribute vec4 aVertexPosition;
	attribute vec2 aTextureCoord;
	varying vec3 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	varying float fog;
	
	void main(void) {
		vec4 transformedCoord = uMVMatrix * aVertexPosition;
		
		gl_Position = uPMatrix * transformedCoord;
		
		fog = 0.5*(1.0 + transformedCoord.w);
		
		vTextureCoord = vec3( aTextureCoord.st, 1.0 );
	}
</script>



<script type="text/javascript">

var shaderProgramColored,
	shaderProgramTexmap,
	shaderProgramTexmap4Vec;
function initShaders(){				
	shaderProgramColored = loadShader( "shader-simple-vs", "shader-simple-fs",{
					attributes:["aVertexPosition","aVertexNormal"],
					uniforms:["uPMatrix","uMVMatrix","uColor","uFogColor", "uModelScale"]
					});
					console.log("loaded 1st shader");
	shaderProgramTexmap = loadShader( "shader-texmap-vs", "shader-texmap-fs",{
					attributes:["aVertexPosition", "aTextureCoord"],
					uniforms:["uPMatrix","uMVMatrix","uSampler","uColor","uFogColor","uModelScale"]
					});
	shaderProgramTexmap4Vec = loadShader( "shader-texmap-vs-4vec", "shader-texmap-fs",{
					attributes:["aVertexPosition", "aTextureCoord"],
					uniforms:["uPMatrix","uMVMatrix","uSampler","uColor","uFogColor"]
					});
}





var vertexPositionBuffer;
var vertexIndexBuffer;

var cubeVertexPositionBuffer;
var cubeVertexTextureCoordBuffer;
var cubeVertexIndexBuffer;

var tennisBallVertexPositionBuffer,
    tennisBallVertexTextureCoordBuffer,
	tennisBallVertexIndexBuffer;

var cubeFrameBuffers={};
var octoFrameBuffers={};	
var tetraFrameBuffers={};	
var dodecaFrameBuffers={};	
var teapotBuffers={};	
var sshipBuffers={};
var gunBuffers={};

function initBuffers(){
	var sphereData = makeSphereData(61,32,0.05);

	vertexPositionBuffer = gl.createBuffer();
	bufferArrayData(vertexPositionBuffer, sphereData.vertices, 3);

	var indexData = sphereData.indices;
	vertexIndexBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
	vertexIndexBuffer.itemSize = 3;
	vertexIndexBuffer.numItems = indexData.length;
	
	//cube. data is in data/levelCubeData.js
	cubeVertexPositionBuffer= gl.createBuffer();
	bufferArrayData(cubeVertexPositionBuffer, levelCubeData.vertices, 3);
	
	cubeVertexTextureCoordBuffer= gl.createBuffer();
	bufferArrayData(cubeVertexTextureCoordBuffer, levelCubeData.uvcoords, 2);
	
	cubeVertexIndexBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(levelCubeData.indices), gl.STATIC_DRAW);
	cubeVertexIndexBuffer.itemSize = 3;
	cubeVertexIndexBuffer.numItems = levelCubeData.indices.length;
	
	//"tennis ball". data in data/tennisBall.js
	tennisBallVertexPositionBuffer = gl.createBuffer();
	bufferArrayData(tennisBallVertexPositionBuffer, tennisBallData.vertices, 4);
	tennisBallVertexTextureCoordBuffer= gl.createBuffer();
	bufferArrayData(tennisBallVertexTextureCoordBuffer, tennisBallData.uvcoords, 2);
	tennisBallVertexIndexBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tennisBallVertexIndexBuffer);
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(tennisBallData.indices), gl.STATIC_DRAW);
	tennisBallVertexIndexBuffer.itemSize = 3;
	tennisBallVertexIndexBuffer.numItems = tennisBallData.indices.length;
	
	//load blender object
	//TODO use XMLHTTPRequest or something
	//for now have put "var myBlenderObjOrWhatever = " in front of contents of untitled.obj.json, and are referencing this directly as a script (similar to how are doing with shaders)
	//this part will eventually want to make part of build process (so can load object just containing what need)
	var cubeFrameBlenderObject = loadBlenderExport(cubeFrameData.meshes[0]);
	var octoFrameBlenderObject = loadBlenderExport(octoFrameData.meshes[0]);
	var tetraFrameBlenderObject = loadBlenderExport(tetraFrameData.meshes[0]);
	var dodecaFrameBlenderObject = loadBlenderExport(dodecaFrameData.meshes[0]);
	var teapotObject = loadBlenderExport(teapotData);	//isn't actually a blender export - just a obj json
	var sshipObject = loadBlenderExport(sshipdata);		//""
	var gunObject = loadBlenderExport(guncyldata.meshes[0]);
	
	loadBufferData(cubeFrameBuffers, cubeFrameBlenderObject);
	loadBufferData(octoFrameBuffers, octoFrameBlenderObject);
	loadBufferData(tetraFrameBuffers, tetraFrameBlenderObject);
	loadBufferData(dodecaFrameBuffers, dodecaFrameBlenderObject);
	loadBufferData(teapotBuffers, teapotObject, true);
	loadBufferData(sshipBuffers, sshipObject, true);
	loadBufferData(gunBuffers, gunObject, true);
	
	function bufferArrayData(buffer, arr, size){
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr), gl.STATIC_DRAW);
		buffer.itemSize = size;
		buffer.numItems = arr.length / size;
		console.log("buffered. numitems: " + buffer.numItems);
	}
	
	function loadBufferData(bufferObj, sourceData, bufferNormals){
		bufferObj.vertexPositionBuffer = gl.createBuffer();
		bufferArrayData(bufferObj.vertexPositionBuffer, sourceData.vertices, 3);
		if (sourceData.uvcoords){
			bufferObj.vertexTextureCoordBuffer= gl.createBuffer();
			bufferArrayData(bufferObj.vertexTextureCoordBuffer, sourceData.uvcoords, 2);
		}
		if (bufferNormals){
			bufferObj.vertexNormalBuffer= gl.createBuffer();
			bufferArrayData(bufferObj.vertexNormalBuffer, sourceData.normals, 3);
		}

		bufferObj.vertexIndexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferObj.vertexIndexBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sourceData.indices), gl.STATIC_DRAW);
		bufferObj.vertexIndexBuffer.itemSize = 3;
		bufferObj.vertexIndexBuffer.numItems = sourceData.indices.length;
	}
	
	function loadBlenderExport(meshToLoad){
		return {
			vertices: meshToLoad.vertices,
			normals: meshToLoad.normals,
			uvcoords: meshToLoad.texturecoords?meshToLoad.texturecoords[0]:false,
			indices: [].concat.apply([],meshToLoad.faces)	//trick from https://www.youtube.com/watch?v=sM9n73-HiNA t~ 28:30
		}	
	};
}

function drawScene(frameTime){
	resizecanvas();

	requestAnimationFrame(drawScene);
	stats.end();
	stats.begin();
	
	//make a pmatrix for hemiphere perspective projection method.
	mat4.identity(pMatrix);	//quickest way i know to set most terms to zero...
	
	var vFov = 90.0;
	var fy = Math.tan((Math.PI/180.0)*vFov/2);
	
	pMatrix[0] = (gl.viewportHeight/gl.viewportWidth)/fy ;
	pMatrix[5] = 1.0/fy;
	pMatrix[11]	= -1;	//rotate w into z.
	pMatrix[14] = -0.01;	//smaller = more z range. 1/50 gets ~same near clipping result as stereographic/perspective 0.01 near
	pMatrix[10]	= 0;
	pMatrix[15] = 0;

	//mat4.set(playerMatrix, playerCamera);
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	drawWorldScene(frameTime, 0);
}

var usePrecalcCells=true;

function drawWorldScene(frameTime) {		
	//var activeShaderProgram = shaderProgramColored;	//draw spheres
	var activeShaderProgram = shaderProgramTexmap;	//draw cubes
	//gl.enableVertexAttribArray(1);	//do need tex coords

	gl.useProgram(activeShaderProgram);
	gl.uniform4fv(activeShaderProgram.uniforms.uFogColor, vecFogColor);
	gl.uniform3fv(activeShaderProgram.uniforms.uModelScale, [0.1,0.1,0.1]);
	//create lines of spheres.
	//unsure which order to apply transformations, so keep simple initially - lines of spheres crossing through default point

	var invertedPlayerCamera = mat4.create();
	mat4.set(playerCamera, invertedPlayerCamera);
	mat4.transpose(invertedPlayerCamera);
	
	var numBallsInRing = 20;
	var startAng = Math.PI / numBallsInRing;
	var angleStep = startAng * 2.0;
	
	gl.uniform4fv(activeShaderProgram.uniforms.uColor, [1.0, 0.4, 0.4, 1.0]);	//RED
	mat4.set(invertedPlayerCamera, mvMatrix);
	//try moving in z first so can see...
	//zmove4matCols(mvMatrix, -0.5);
	
	if (guiParams.drawShapes['boxes y=z=0']){drawRing();}
	
	gl.uniform4fv(activeShaderProgram.uniforms.uColor, [0.4, 1.0, 0.4, 1.0]);	//GREEN
	mat4.set(invertedPlayerCamera, mvMatrix);
	//try moving in z first so can see...
	//zmove4matCols(mvMatrix, -0.5);
	
	rotate4mat(mvMatrix, 0, 1, Math.PI*0.5);
	if (guiParams.drawShapes['boxes x=z=0']){drawRing();}
	
	gl.uniform4fv(activeShaderProgram.uniforms.uColor, [0.4, 0.4, 1.0, 1.0]);	//BLUE
	mat4.set(invertedPlayerCamera, mvMatrix);
	rotate4mat(mvMatrix, 0, 2, Math.PI*0.5);
	if (guiParams.drawShapes['boxes x=y=0']){drawRing();}
	
	gl.uniform4fv(activeShaderProgram.uniforms.uColor, [1.0, 1.0, 0.4, 1.0]);	//YELLOW
	mat4.set(invertedPlayerCamera, mvMatrix);
	xmove4mat(mvMatrix, Math.PI*0.5);
	rotate4mat(mvMatrix, 0, 1, Math.PI*0.5);
	if (guiParams.drawShapes['boxes z=w=0']){drawRing();}
	
	gl.uniform4fv(activeShaderProgram.uniforms.uColor, [1.0, 0.4, 1.0, 1.0]);	//MAGENTA
	mat4.set(invertedPlayerCamera, mvMatrix);
	xmove4mat(mvMatrix, Math.PI*0.5);
	rotate4mat(mvMatrix, 0, 2, Math.PI*0.5);
	if (guiParams.drawShapes['boxes y=w=0']){drawRing();}
	
	gl.uniform4fv(activeShaderProgram.uniforms.uColor, [0.4, 1.0, 1.0, 1.0]);	//CYAN
	mat4.set(invertedPlayerCamera, mvMatrix);
	ymove4mat(mvMatrix, Math.PI*0.5);
	rotate4mat(mvMatrix, 0, 2, Math.PI*0.5);
	if (guiParams.drawShapes['boxes x=w=0']){drawRing();}
	
	
	function drawRing(){
		xmove4mat(mvMatrix, startAng);
		for (var ii=0;ii<numBallsInRing;ii++){
			xmove4mat(mvMatrix, angleStep);
			drawItem();
		}
	}
	
	//draw blender object - a csg cube minus sphere. draw 8 cells for tesseract.
	var modelScale = guiParams["8-cell scale"];
	gl.uniform3fv(activeShaderProgram.uniforms.uModelScale, [modelScale,modelScale,modelScale]);
	
	if (guiParams["draw 8-cell"]){
		var cellMats = cellMatData.d8;	
		gl.uniform4fv(activeShaderProgram.uniforms.uColor, [0.15, 0.15, 0.15, 1.0]);	//DARK GREY
		for (cc in cellMats){
			var thisCell = cellMats[cc];
			mat4.set(invertedPlayerCamera, mvMatrix);
			mat4.multiply(mvMatrix,thisCell);
			drawCubeFrame();
		}
	}
	
	if (guiParams["draw 16-cell"]){
		var cellScale = 4/Math.sqrt(6);		//in the model, vertices are 0.75*sqrt(2) from the centre, and want to scale to tan(PI/3)=sqrt(3)
		var moveAmount = Math.PI/3;	
		gl.uniform3fv(activeShaderProgram.uniforms.uModelScale, [cellScale,cellScale,cellScale]);

		var ang = -0.5*Math.sqrt(2)*Math.atan(Math.sqrt(2));
		
		var tmpMatrix = mat4.create();
		mat4.set(invertedPlayerCamera, tmpMatrix);	//copy matrix so can reuse
		drawHalf16Cells();
		xyzrotate4mat(tmpMatrix,[ Math.PI, 0, 0]);
		drawHalf16Cells();
		
		function drawHalf16Cells(){
			gl.uniform4fv(activeShaderProgram.uniforms.uColor, [1.0, 1.0, 1.0, 1.0]);	//WHITE
			drawTetraFromPair(1,1,1);
			drawTetraFromPair(-1,-1,5);
			gl.uniform4fv(activeShaderProgram.uniforms.uColor, [0.2, 0.2, 0.2, 1.0]);	//DARK
			drawTetraFromPair(1,-1,-1);
			drawTetraFromPair(-1,1,-5);
		}
		
		function drawTetraFromPair(xsign,ysign,rotatesign){
			mat4.set(tmpMatrix, mvMatrix);
			
			xyzrotate4mat(mvMatrix,[ -ang*xsign, 0, -ang*ysign]);
			
			xyzrotate4mat(mvMatrix,[0,rotatesign*Math.PI/12,0]);
			ymove4mat(mvMatrix, moveAmount);

			drawTetraFrame();
			
			ymove4mat(mvMatrix, Math.PI);
			xyzrotate4mat(mvMatrix,[0,Math.PI,0]);
			drawTetraFrame();
		}
	}
	
	modelScale = 1.0;
	gl.uniform3fv(activeShaderProgram.uniforms.uModelScale, [modelScale,modelScale,modelScale]);
	
	if (guiParams["draw 24-cell"]){
		var cellMats=cellMatData.d24.cells;
		var cellColors=cellMatData.d24.colors;
		for (cc in cellMats){
			var thisCell = cellMats[cc];
			gl.uniform4fv(activeShaderProgram.uniforms.uColor,cellColors[cc]);
			mat4.set(invertedPlayerCamera, mvMatrix);
			mat4.multiply(mvMatrix,thisCell);
			drawOctoFrame();
		}
	}
	
	if (guiParams["draw 5-cell"]){
		var cellMats = cellMatData.d5;
		var moveDist = Math.acos(-0.25);
		modelScale = 2*moveDist;

		var cellColors = [
			[1.0, 1.0, 1.0, 1.0],	//WHITE
			[1.0, 0.4, 1.0, 1.0],	//MAGENTA
			[1.0, 1.0, 0.4, 1.0],	//YELLOW
			[0.4, 1.0, 0.4, 1.0],	//GREEN
			[1.0, 0.4, 0.4, 1.0]	//RED
		];
						
		gl.uniform3fv(activeShaderProgram.uniforms.uModelScale, [modelScale,modelScale,modelScale]);
		for (cc in cellMats){
			gl.uniform4fv(activeShaderProgram.uniforms.uColor, cellColors[cc]);
			var thisCell = cellMats[cc];
			mat4.set(invertedPlayerCamera, mvMatrix);
			mat4.multiply(mvMatrix,thisCell);
			drawTetraFrame();
		}
	}
	
	mat4.set(invertedPlayerCamera, mvMatrix);
	
	
	//new draw dodeca stuff...
	if (guiParams["draw 120-cell"]){
		var cellMats = cellMatData.d120;
		var dodecaScale=0.5;	//guess
		gl.uniform3fv(activeShaderProgram.uniforms.uModelScale, [dodecaScale,dodecaScale,dodecaScale]);
		for (cc in cellMats){
			var thisCell = cellMats[cc];
			mat4.set(invertedPlayerCamera, mvMatrix);
			mat4.multiply(mvMatrix,thisCell);
			drawDodecaFrame();
		}
	}
	
	if (guiParams["draw 600-cell"]){
		var cellMats = cellMatData.d600;
		var myscale=0.385;	//todo use correct scale
		gl.uniform3fv(activeShaderProgram.uniforms.uModelScale, [myscale,myscale,myscale]);
		gl.uniform4fv(activeShaderProgram.uniforms.uColor, [0.4, 0.4, 0.4, 1.0]);	//DARK
		for (cc in cellMats){
			var thisCell = cellMats[cc];
			mat4.set(invertedPlayerCamera, mvMatrix);
			mat4.multiply(mvMatrix,thisCell);
			drawTetraFrame();
		}
	}
	
	activeShaderProgram = shaderProgramTexmap4Vec;
	gl.useProgram(activeShaderProgram);
	gl.uniform4fv(activeShaderProgram.uniforms.uFogColor, vecFogColor);
	gl.uniform4fv(activeShaderProgram.uniforms.uColor, [1.0, 1.0, 1.0, 1.0]);
	if (guiParams.drawShapes['x*x+y*y=z*z+w*w']){
		mat4.set(invertedPlayerCamera, mvMatrix);
		drawTennisBall();
	}
	if (guiParams.drawShapes['x*x+w*w=y*y+z*z']){
		mat4.set(invertedPlayerCamera, mvMatrix);
		rotate4mat(mvMatrix, 0, 2, Math.PI*0.5);
		drawTennisBall();
	}
	if (guiParams.drawShapes['x*x+z*z=y*y+w*w']){
		mat4.set(invertedPlayerCamera, mvMatrix);
		rotate4mat(mvMatrix, 0, 3, Math.PI*0.5);
		drawTennisBall();
	}
	
	function drawCubeFrame(){
		drawObjectFromBuffers(cubeFrameBuffers, shaderProgramTexmap);
	}
	function drawOctoFrame(){
		drawObjectFromBuffers(octoFrameBuffers, shaderProgramTexmap);
	}
	function drawTetraFrame(){
		drawObjectFromBuffers(tetraFrameBuffers, shaderProgramTexmap);
	}
	function drawDodecaFrame(){
		drawObjectFromBuffers(dodecaFrameBuffers, shaderProgramTexmap);
	}
	
	
	//draw objects without textures
	
	activeShaderProgram = shaderProgramColored;
	gl.useProgram(activeShaderProgram);
	gl.uniform4fv(activeShaderProgram.uniforms.uFogColor, vecFogColor);
	//gl.disableVertexAttribArray(1);	//don't need texcoords
	
	gl.uniform4fv(activeShaderProgram.uniforms.uColor, [0.4, 0.4, 0.8, 1.0]);	//BLUE
	modelScale = guiParams["teapot scale"];
	gl.uniform3fv(activeShaderProgram.uniforms.uModelScale, [modelScale,modelScale,modelScale]);
	if (guiParams["draw teapot"]){
		mat4.set(invertedPlayerCamera, mvMatrix);
		mat4.multiply(mvMatrix,teapotMatrix);		
		drawObjectFromBuffers(teapotBuffers, shaderProgramColored);
	}
	
	modelScale=0.002;
	gl.uniform4fv(activeShaderProgram.uniforms.uColor, [0.2, 0.2, 0.2, 1.0]);	//GREY
	gl.uniform3fv(activeShaderProgram.uniforms.uModelScale, [modelScale,modelScale,modelScale]);
	if (guiParams["draw spaceship"]){
		mat4.set(invertedPlayerCamera, mvMatrix);
		mat4.multiply(mvMatrix,sshipMatrix);		
		drawObjectFromBuffers(sshipBuffers, shaderProgramColored);
		
		//draw guns
		gl.uniform3fv(activeShaderProgram.uniforms.uModelScale, [0.1,0.1,0.1]);
		gl.uniform4fv(activeShaderProgram.uniforms.uColor, [0.3, 0.3, 0.3, 1.0]);	//GREY

		var gunHoriz = 0.04;
		var gunVert = 0.02;
		var gunFront = 0.05;

		drawRelativeToSpacehip([gunHoriz,gunVert,gunFront]); //left, down, forwards
		drawRelativeToSpacehip([-gunHoriz,gunVert,gunFront]);
		drawRelativeToSpacehip([gunHoriz,-gunVert,gunFront]);
		drawRelativeToSpacehip([-gunHoriz,-gunVert,gunFront]);
		
		function drawRelativeToSpacehip(vec){
			mat4.set(invertedPlayerCamera, mvMatrix);
			mat4.multiply(mvMatrix,sshipMatrix);
			xyzmove4mat(mvMatrix,vec);
			drawObjectFromBuffers(gunBuffers, shaderProgramColored);
		}
		
	}
}


function drawItem(){
	gl.enable(gl.CULL_FACE);
	//drawSphere();
	drawCube();
}

function drawSphere(){
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgramColored.attributes.aVertexPosition, vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);
		
    setMatrixUniforms(shaderProgramColored);
				
    gl.drawElements(gl.TRIANGLES, vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
}

function drawCube(){
	//gl.useProgram(shaderProgramTexmap);
	//gl.enableVertexAttribArray(1);
	
	//a lot of this stuff likely doesn't need to be done every time when draing a load of cubes sequentially
	
	gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
	gl.vertexAttribPointer(shaderProgramTexmap.attributes.aVertexPosition, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
	gl.vertexAttribPointer(shaderProgramTexmap.attributes.aTextureCoord, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
	setMatrixUniforms(shaderProgramTexmap);
	
	//gl.uniform4fv(shaderProgramTexmap.uniforms.uTintColor, [1.0,0.5,0.5,1.0]);	//set tint colour
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.uniform1i(shaderProgramTexmap.uniforms.uSampler, 0);
	
	gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
}

function drawTennisBall(){
	gl.disable(gl.CULL_FACE);
	gl.bindBuffer(gl.ARRAY_BUFFER, tennisBallVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgramTexmap4Vec.attributes.aVertexPosition, tennisBallVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
	gl.bindBuffer(gl.ARRAY_BUFFER, tennisBallVertexTextureCoordBuffer);
	gl.vertexAttribPointer(shaderProgramTexmap4Vec.attributes.aTextureCoord, tennisBallVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tennisBallVertexIndexBuffer);
	setMatrixUniforms(shaderProgramTexmap4Vec);
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.uniform1i(shaderProgramTexmap4Vec.uniforms.uSampler, 0);
	
	gl.drawElements(gl.TRIANGLES, tennisBallVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
}

function drawObjectFromBuffers(bufferObj, shaderProg){
	gl.enable(gl.CULL_FACE);
	gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexPositionBuffer);
    gl.vertexAttribPointer(shaderProg.attributes.aVertexPosition, bufferObj.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
	if (bufferObj.vertexNormalBuffer){
		gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexNormalBuffer);
		gl.vertexAttribPointer(shaderProg.attributes.aVertexNormal, bufferObj.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
	}
	
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferObj.vertexIndexBuffer);
	setMatrixUniforms(shaderProg);
	
	if (bufferObj.vertexTextureCoordBuffer){
		gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexTextureCoordBuffer);
		gl.vertexAttribPointer(shaderProg.attributes.aTextureCoord, bufferObj.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.uniform1i(shaderProg.uniforms.uSampler, 0);
	}
	
	gl.drawElements(gl.TRIANGLES, bufferObj.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
}

//need all of these???
var mvMatrix = mat4.create();
var pMatrix = mat4.create();
var playerMatrix = mat4.create();
var playerCamera = mat4.create();

function setMatrixUniforms(shaderProgram) {
    gl.uniformMatrix4fv(shaderProgram.uniforms.uPMatrix, false, pMatrix);
    gl.uniformMatrix4fv(shaderProgram.uniforms.uMVMatrix, false, mvMatrix);
}

function setupScene() {
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	
	mat4.identity(playerMatrix);
	mat4.identity(playerCamera);	//not sure why have 2 matrices here...
	
	//start player off outside of boxes
	xyzmove4mat(playerCamera,[0,0.7,-1.0]);
}

var texture;
function initTexture() {
	texture = gl.createTexture();
	texture.image = new Image();
	texture.image.onload = function() {
		gl.bindTexture(gl.TEXTURE_2D, texture);
		//gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
		//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.generateMipmap(gl.TEXTURE_2D);
		gl.bindTexture(gl.TEXTURE_2D, null);
	}
	texture.image.src = "img/ash_uvgrid01-grey.tiny.png";
	//texture.image.src = "img/cross.png";
}

var mouseInfo = {
	x:0,
	y:0,
	dragging: false,
	lastPointingDir:{}
};
var stats;

var guiParams={
	drawShapes:{
		'x*x+y*y=z*z+w*w':false,
		'x*x+z*z=y*y+w*w':false,
		'x*x+w*w=y*y+z*z':false,
		'boxes y=z=0':false,	//x*x+w*w=1
		'boxes x=z=0':false,	//y*y+w*w=1
		'boxes x=y=0':false,	//z*z+w*w=1
		'boxes x=w=0':false,
		'boxes y=w=0':false,
		'boxes z=w=0':false
	},
	"draw 5-cell":false,
	"8-cell scale":1.0,
	"draw 8-cell":false,
	"draw 16-cell":false,
	"draw 24-cell":false,
	"draw 120-cell":false,
	"draw 600-cell":false,
	"draw teapot":false,
	"teapot scale":1.0,
	"draw spaceship":true,
	"drop spaceship":function(){dropSpaceship();},
	fogColor:'#aaaaaa'
};
var vecFogColor = [1.0,0.0,0.0,1.0];
var teapotMatrix=mat4.create();mat4.identity(teapotMatrix);
var sshipMatrix=mat4.create();mat4.identity(sshipMatrix);
var canvas;
function init(){

	stats = new Stats();
	stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
	document.body.appendChild( stats.dom );

	var gui = new dat.GUI();
	gui.addColor(guiParams, 'fogColor').onChange(function(color){
		setFog(color);
	});
	var drawShapesFolder = gui.addFolder('drawShapes');
	for (shape in guiParams.drawShapes){
		console.log(shape);
		drawShapesFolder.add(guiParams.drawShapes, shape );
	}
	gui.add(guiParams,"draw 5-cell");
	gui.add(guiParams,"draw 8-cell",false);
	gui.add(guiParams,"draw 16-cell");
	gui.add(guiParams,"8-cell scale",0.2,2.0,0.05);
	gui.add(guiParams,"draw 24-cell",true);
	gui.add(guiParams,"draw 120-cell",true);
	gui.add(guiParams,"draw 600-cell",true);
	gui.add(guiParams,"draw teapot",true);
	gui.add(guiParams,"teapot scale",0.2,2.0,0.05);
	gui.add(guiParams,"draw spaceship",true);
	gui.add(guiParams, "drop spaceship");
	
	window.addEventListener("keydown",function(evt){
		//console.log("key pressed : " + evt.keyCode);
		var willPreventDefault=true;
		switch (evt.keyCode){
			case 87:				//W
				movePlayer(0.01);
				break;
			case 83:				//S
				movePlayer(-0.01);
				break;
			case 65:				//A
				movePlayerLeft(0.01);
				break;
			case 68:				//D
				movePlayerLeft(-0.01);
				break;
			case 39:
				turnPlayer(0.02);
				break;
			case 37:
				turnPlayer(-0.02);
				break;
			case 81:				//Q
				rollPlayer(-0.02);	
				break;
			case 69:				//E
				rollPlayer(0.02);	
				break;
			
			case 84:	//T
				//xyzmove4mat(playerCamera,[0.01,0.0,0.0]);	//left
				//xyzmove4mat(playerCamera,[0.0,0.01,0.0]);	//down
				//xyzmove4mat(playerCamera,[0.0,0.0,0.01]);	//forwards
				xyzmove4mat(playerCamera,[0.01,0.0,0.01]);	//diagonally forwards/left
				break;
				
			case 32:				//spacebar
				movePlayerUp(-0.01);
				break;
			case 17:				//ctrl
				movePlayerUp(0.01);
				break;
			case 38:
				pitchPlayer(-0.02);		//up arrow
				break;
			case 40:
				pitchPlayer(0.02);
				break;
			default:
				willPreventDefault=false;
				break;
		}
		if (willPreventDefault){evt.preventDefault()};
		printPlayerPosition();
	})

	canvas = document.getElementById("mycanvas");
	canvas.addEventListener("mousedown", function(evt){
		mouseInfo.x = evt.offsetX;
		mouseInfo.y = evt.offsetY;
		mouseInfo.dragging = true;
		mouseInfo.lastPointingDir = getPointingDirectionFromScreenCoordinate({x:mouseInfo.x, y: mouseInfo.y});
	});
	canvas.addEventListener("mouseup", function(evt){
		mouseInfo.dragging = false;
	});
	canvas.addEventListener("mouseout", function(evt){
		mouseInfo.dragging = false;
	});
	canvas.addEventListener("mousemove", function(evt){
		if (mouseInfo.dragging){
			//console.log("evt offsetX = " + evt.offsetX + ", offsetY = " + evt.offsetY);
			//console.log("moved : " + evt.movementX + ", movementY = " + evt.movementY);	//this is very nearly the same as the calculated version
			//console.log("calculated moved : " + (evt.offsetX - mouseInfo.x) + ", movementY = " + (evt.offsetY - mouseInfo.y) );
			mouseInfo.x = evt.offsetX;
			mouseInfo.y = evt.offsetY;
			
			var pointingDir = getPointingDirectionFromScreenCoordinate({x:mouseInfo.x, y: mouseInfo.y});
			//console.log("pointingDir = " + pointingDir);
			
			//get the direction of current and previous mouse position.
			//do a cross product to work out the angle rotated
			//and rotate the player by this amount
			
			var crossProd = crossProductHomgenous(pointingDir, mouseInfo.lastPointingDir);
			mouseInfo.lastPointingDir = pointingDir;
			
			//rotate player 
			//guess have signs here because of unplanned handedness of screen, 3d co-ord systems
			xyzrotate4mat(playerCamera, [crossProd.x / crossProd.w, -crossProd.y / crossProd.w, -crossProd.z / crossProd.w]);
			
		}
	});
	
	canvas.addEventListener("touchstart", handleTouchStart, false);
	canvas.addEventListener("touchend", handleTouchEnd, false);
	canvas.addEventListener("touchmove", handleTouchMove, false);
	
	initGL();
	initShaders();
	initTexture();
	initBuffers();
	setFog(guiParams.fogColor);
    gl.enable(gl.DEPTH_TEST);
	//gl.disable(gl.DEPTH_TEST);
	setupScene();
	requestAnimationFrame(drawScene);
	
	function setFog(color){
			var r = parseInt(color.substring(1,3),16) /255;
			var g = parseInt(color.substring(3,5),16) /255;
			var b = parseInt(color.substring(5,7),16) /255;
			vecFogColor = [r,g,b,1];
			gl.clearColor(r,g,b,1);
	}

}


function movePlayer(amount){
	zmove4mat(playerCamera, amount);
}
function movePlayerLeft(amount){
	xmove4mat(playerCamera, amount);
}
function movePlayerUp(amount){
	ymove4mat(playerCamera, amount);
}
function rollPlayer(amount){
	rotate4mat(playerCamera, 0, 1, -amount);
}
function turnPlayer(amount){
	rotate4mat(playerCamera, 0, 2, amount);
}
function pitchPlayer(amount){
	rotate4mat(playerCamera, 1, 2, -amount);
}

function printPlayerPosition(){
	console.log('position: x = ' + playerCamera[12].toFixed(2) + ', y = ' + playerCamera[13].toFixed(2) + 
						', z = ' + playerCamera[14].toFixed(2) + ', w = ' + playerCamera[15].toFixed(2) );
}



function getPointingDirectionFromScreenCoordinate(coords){
	
	var maxyvert = 1.0;	
	var maxxvert = screenAspect;
	
	var xpos = maxxvert*(coords.x*2.0/gl.viewportWidth   -1.0 );
	var ypos = maxyvert*(coords.y*2.0/gl.viewportHeight   -1.0 );
	var radsq = xpos*xpos + ypos*ypos;
	var zpos = 1.0;	//FOV 90 deg
	
	//normalise - use sending back homogenous co-ords because maybe a tiny amount more efficient since cross producting anyway
	var mag= Math.sqrt(radsq + zpos*zpos);
	
	return {
		x: xpos,
		y: ypos,
		z: zpos,
		w: mag
	}
}

function crossProductHomgenous(dir1, dir2){
	var output ={};
	output.x = dir1.y * dir2.z - dir1.z * dir2.y; 
	output.y = dir1.z * dir2.x - dir1.x * dir2.z; 
	output.z = dir1.x * dir2.y - dir1.y * dir2.x;
	output.w = dir1.w * dir2.w;
	return output;
}


var ongoingTouches = {};

function handleTouchStart(evt){
	evt.preventDefault();
	var touches = evt.changedTouches;
	log( touches.length + " touches starting");
		
	for (var i = 0; i < touches.length; i++) {
		var thisTouch = copyTouch(touches[i]);
		var touchIdx = touches[i].identifier;
		ongoingTouches[touchIdx] = thisTouch;
		logtouchevent(touches[i],i);
	}
}

function handleTouchMove(evt){
	evt.preventDefault();
	var touches = evt.changedTouches;
	log( touches.length + " touches moving");
	
	for (var i = 0; i < touches.length; i++) {
		
		var thisTouch = copyTouch(touches[i]);
		var touchIdx = touches[i].identifier;
		
		//copy previous position to new touch
		toTouch = ongoingTouches[touchIdx];
		thisTouch.oldx = toTouch.x;
		thisTouch.oldy = toTouch.y;
		ongoingTouches[touchIdx] = thisTouch;
		
		//do do the equivalent of mouse move
		if (i==0){
			//what behaviour will be if there are >1 touches?
			
			var oldPointingDir = getPointingDirectionFromScreenCoordinate({x:thisTouch.oldx, y: thisTouch.oldy});
			var pointingDir = getPointingDirectionFromScreenCoordinate({x:thisTouch.x, y: thisTouch.y});
			
			var crossProd = crossProductHomgenous(pointingDir, oldPointingDir);
			mouseInfo.lastPointingDir = pointingDir;
			
			//rotate player 
			//guess have signs here because of unplanned handedness of screen, 3d co-ord systems
			xyzrotate4mat(playerCamera, [crossProd.x / crossProd.w, -crossProd.y / crossProd.w, -crossProd.z / crossProd.w]);
		}
		
		logtouchevent(touches[i],i);
	}
}

function handleTouchEnd(evt){
	evt.preventDefault();
	var touches = evt.changedTouches;
	log( touches.length + " touches ending");
	for (var i = 0; i < touches.length; i++) {
		logtouchevent(touches[i],i);
		delete ongoingTouches[touches.identifier];
	}
}

function logtouchevent(t,i){
	//log("i = " + i + " , idx = " + t.identifier + ". radiusX : " + t.radiusX + " , radiusY : " + t.radiusY);
	log("i = " + i + " , idx = " + t.identifier + ". x : " + t.pageX + " , y : " + t.pageY);
}

//https://developer.mozilla.org/en-US/docs/Web/API/Touch_events
//says this is useful since the touch object might change.
function copyTouch(touch) {
  return { x: touch.pageX, y: touch.pageY, force:touch.force };
}

function log(info){		//can to enable/disable logging globally
	//console.log(info);
}
function dropSpaceship(){
	mat4.set(playerCamera,sshipMatrix);	//copy current player 4-rotation matrix to the spaceship object
}


</script>




</head>



<body onload="init()">
<div id="info">3-sphere visualised in WebGL demo. Arrow keys, QE, click+drag mouse to rotate. WASD, space/ctrl to translate.<a href="https://github.com/filbs111/3sphere-explorer" target="_blank">https://github.com/filbs111/3sphere-explorer</a></div>
		

<canvas id="mycanvas" width="0" height="0">CANVAS TO GO HERE</canvas>


</body>


</html>